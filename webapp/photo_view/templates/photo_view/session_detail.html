{% extends 'base.html' %}
{% block title %}Session Details{% endblock %}

{% block extra_head %}
<script src="{{ url_for('static', filename='js/pagination.js') }}"></script>
{% endblock %}

{% block content %}
<div class="d-flex flex-column flex-lg-row gap-2 align-items-lg-center justify-content-lg-between mb-3">
  <div>
    <h1 id="session-title" class="mb-1">{{ _("Session Details") }}</h1>
    <p id="session-subtitle" class="text-muted small mb-0 d-none"></p>
  </div>
  <a href="/photo-view" class="btn btn-outline-secondary btn-sm">
    <i class="bi bi-arrow-left"></i> {{ _("Back to Sessions") }}
  </a>
</div>

<div class="mb-3">
  <div class="d-flex flex-wrap gap-2">
    <button id="btn-import-start" class="btn btn-primary" disabled aria-disabled="true">
      {{ _("Start Import") }}
    </button>
    <button id="btn-local-import-stop" class="btn btn-outline-danger d-none" type="button">
      <i class="bi bi-stop-circle"></i> {{ _("Stop Local Import") }}
    </button>
  </div>
  <div id="local-import-status" class="mt-2 small text-muted d-none"></div>
  <div id="session-info" class="text-muted mt-2">
    {{ _("Loading session info...") }}
  </div>
</div>

<div id="import-status" class="mt-3" aria-live="polite"></div>

<div class="mt-4">
  <h2>{{ _("Selected Files") }}</h2>
  <p class="text-muted small mb-2">
    <i class="bi bi-info-circle"></i> {{ _("Failed files will be retried up to three times.") }}
  </p>
  <div id="selection-counts" class="mb-2 text-muted">{{ _("Loading...") }}</div>
  <div class="table-responsive">
    <table class="table table-sm">
      <thead>
        <tr>
          <th>{{ _("File") }}</th>
          <th>{{ _("Status") }}</th>
          <th>{{ _("Attempts") }}</th>
          <th>{{ _("Error") }}</th>
        </tr>
      </thead>
      <tbody id="selection-body">
        <!-- アイテムが動的に追加されます -->
      </tbody>
    </table>
  </div>
</div>

<div id="local-import-logs-section" class="mt-4 d-none">
  <h2>{{ _("Import Logs") }}</h2>
  <p class="text-muted small mb-2">
    <i class="bi bi-info-circle"></i> {{ _("ZIP extraction and file processing logs appear here while local import runs.") }}
  </p>
  <div class="table-responsive">
    <table class="table table-sm mb-0">
      <thead>
        <tr>
          <th style="width: 18%">{{ _("Time") }}</th>
          <th style="width: 18%">{{ _("Event") }}</th>
          <th style="width: 12%">{{ _("Level") }}</th>
          <th>{{ _("Message") }}</th>
        </tr>
      </thead>
      <tbody id="local-import-log-body">
        <tr id="local-import-log-empty">
          <td colspan="4" class="text-center text-muted py-3">{{ _("No logs yet.") }}</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<div id="server-data" 
     data-picker-session-id="{{ picker_session_id or '' }}" 
     style="display: none;"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  function escapeHtml(value) {
    if (value === null || value === undefined) {
      return '';
    }
    return String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function resolveSessionId() {
    const params = new URLSearchParams(window.location.search);
    const fromQuery = params.get('session_id');
    if (fromQuery) return fromQuery;
    const serverDataEl = document.getElementById('server-data');
    const fromServer = serverDataEl.getAttribute('data-picker-session-id');
    return fromServer || '';
  }

  const pickerSessionId = resolveSessionId();
  if (!pickerSessionId) {
    window.location.href = '/photo-view';
    return;
  }

  if (/^\d+$/.test(pickerSessionId)) {
    console.warn('Numeric session ID detected, redirecting to sessions list');
    window.location.href = '/photo-view';
    return;
  }

  const importBtn = document.getElementById('btn-import-start');
  const stopLocalImportBtn = document.getElementById('btn-local-import-stop');
  const statusEl = document.getElementById('import-status');
  const selectionBody = document.getElementById('selection-body');
  const countsEl = document.getElementById('selection-counts');
  const sessionInfoEl = document.getElementById('session-info');
  const sessionTitleEl = document.getElementById('session-title');
  const sessionSubtitleEl = document.getElementById('session-subtitle');
  const localImportStatusEl = document.getElementById('local-import-status');
  const logSection = document.getElementById('local-import-logs-section');
  const logBody = document.getElementById('local-import-log-body');

  const selectionStatusLabels = {
    pending: '{{ _("Pending") }}',
    enqueued: '{{ _("Enqueued") }}',
    running: '{{ _("Running") }}',
    imported: '{{ _("Imported") }}',
    failed: '{{ _("Failed") }}',
    dup: '{{ _("Duplicate") }}',
    skipped: '{{ _("Skipped") }}'
  };

  const sessionStatusLabels = {
    pending: '{{ _("Pending") }}',
    ready: '{{ _("Ready") }}',
    expanding: '{{ _("Expanding") }}',
    processing: '{{ _("Processing") }}',
    enqueued: '{{ _("Enqueued") }}',
    importing: '{{ _("Importing") }}',
    imported: '{{ _("Imported") }}',
    canceled: '{{ _("Canceled") }}',
    expired: '{{ _("Expired") }}',
    error: '{{ _("Error") }}',
    failed: '{{ _("Failed") }}'
  };

  const sessionStageLabels = {
    expanding: '{{ _("Expanding") }}',
    processing: '{{ _("Processing") }}',
    importing: '{{ _("Importing") }}'
  };

  const noLogsMessage = '{{ _("No logs yet.") }}';

  const localImportRunningMessage = '{{ _("Local import is running. You can stop it if needed.") }}';
  const localImportCancelingMessage = '{{ _("Canceling local import...") }}';
  const localImportCanceledMessage = '{{ _("Local import was canceled.") }}';
  const localImportStopFailedMessage = '{{ _("Failed to stop local import.") }}';

  function getStatusBadgeClass(status) {
    switch (status) {
      case 'pending': return 'secondary';
      case 'enqueued': return 'info';
      case 'running': return 'warning';
      case 'imported': return 'success';
      case 'failed': return 'danger';
      case 'dup': return 'light text-dark border border-secondary-subtle';
      default: return 'secondary';
    }
  }

  function getSessionBadgeClass(status) {
    switch (status) {
      case 'pending': return 'secondary';
      case 'ready': return 'primary';
      case 'expanding': return 'warning';
      case 'processing': return 'warning';
      case 'importing': return 'info';
      case 'imported': return 'success';
      case 'expired': return 'danger';
      case 'error':
      case 'failed':
        return 'danger';
      default:
        return 'secondary';
    }
  }

  function getLevelBadgeClass(level) {
    switch ((level || '').toUpperCase()) {
      case 'ERROR':
      case 'CRITICAL':
        return 'danger';
      case 'WARNING':
        return 'warning';
      case 'INFO':
        return 'info';
      case 'DEBUG':
        return 'secondary';
      default:
        return 'secondary';
    }
  }

  function formatLogDetails(details) {
    if (!details || typeof details !== 'object') {
      return '';
    }

    const entries = Object.entries(details)
      .map(([key, value]) => {
        if (value === null || value === undefined || value === '') {
          return null;
        }
        let normalized = value;
        if (typeof normalized === 'object') {
          try {
            normalized = JSON.stringify(normalized);
          } catch (err) {
            normalized = String(normalized);
          }
        }
        return `${escapeHtml(key)}=${escapeHtml(String(normalized))}`;
      })
      .filter(Boolean);

    return entries.join(', ');
  }

  function renderLocalImportLogs(logs = [], showSection = isLocalImport) {
    if (!logSection || !logBody) {
      return;
    }

    if (!showSection) {
      logSection.classList.add('d-none');
      logBody.innerHTML = '';
      return;
    }

    logSection.classList.remove('d-none');
    logBody.innerHTML = '';

    if (!logs || logs.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.id = 'local-import-log-empty';
      emptyRow.innerHTML = `<td colspan="4" class="text-center text-muted py-3">${escapeHtml(noLogsMessage)}</td>`;
      logBody.appendChild(emptyRow);
      return;
    }

    logs.forEach((log) => {
      const row = document.createElement('tr');
      const level = (log.level || '').toUpperCase();
      const badgeClass = getLevelBadgeClass(level);
      const detailsText = formatLogDetails(log.details);

      const messageHtml = [
        escapeHtml(log.message || ''),
        detailsText ? `<div class="text-muted small">${detailsText}</div>` : ''
      ].join('');

      row.innerHTML = `
        <td>${escapeHtml(formatDateTime(log.createdAt))}</td>
        <td>${log.event ? `<code>${escapeHtml(log.event)}</code>` : '-'}</td>
        <td>${level ? `<span class="badge bg-${badgeClass}">${escapeHtml(level)}</span>` : '-'}</td>
        <td>${messageHtml}</td>
      `;

      logBody.appendChild(row);
    });
  }

  let paginationClient;
  let isLocalImport = false;
  let latestStatus = 'unknown';
  let isRefreshing = false;
  let currentCounts = {};

  function formatDateTime(isoString) {
    if (!isoString) return '-';
    const helper = window.appTime;
    if (helper && typeof helper.formatDateTime === 'function') {
      const formatted = helper.formatDateTime(isoString);
      if (formatted) {
        return formatted;
      }
    }
    try {
      const date = new Date(isoString);
      return Number.isNaN(date.getTime()) ? '-' : date.toLocaleString();
    } catch (e) {
      return isoString;
    }
  }

  function formatCounts(counts) {
    if (!counts || Object.keys(counts).length === 0) {
      return '';
    }
    return Object.entries(counts)
      .map(([status, count]) => `${selectionStatusLabels[status] || status}: ${count}`)
      .join(', ');
  }

  function totalFromCounts(counts = {}) {
    return Object.values(counts).reduce((total, value) => total + (Number(value) || 0), 0);
  }

  function duplicateCount(counts = {}) {
    return Number(counts?.dup || 0);
  }

  function hasOnlyDuplicates(counts = {}) {
    let dupTotal = 0;
    let otherTotal = 0;

    Object.entries(counts).forEach(([status, count]) => {
      const numericCount = Number(count) || 0;
      if (status === 'dup') {
        dupTotal += numericCount;
      } else if (numericCount > 0) {
        otherTotal += numericCount;
      }
    });

    return dupTotal > 0 && otherTotal === 0;
  }

  function determineDisplayStatus(sessionData) {
    const baseStatus = sessionData?.status || 'pending';
    if (['processing', 'importing', 'error', 'failed'].includes(baseStatus) && hasOnlyDuplicates(sessionData?.counts || {})) {
      return 'imported';
    }
    return baseStatus;
  }

  function deriveSelectedCount(sessionData) {
    const countsTotal = totalFromCounts(sessionData?.counts || {});
    if (countsTotal > 0) {
      return countsTotal;
    }
    const selected = sessionData?.selectedCount;
    if (typeof selected === 'number' && selected > 0) {
      return selected;
    }
    return selected || 0;
  }

  function createSelectionRow(selection) {
    const tr = document.createElement('tr');
    const displayName = selection.filename || selection.googleMediaId || 'N/A';
    const safeDisplayName = escapeHtml(displayName);
    const canDisplayLink = selection.mediaId && ['imported', 'dup'].includes(selection.status);
    const fileCellContent = canDisplayLink
      ? `<a href="/photo-view/media/${selection.mediaId}" class="text-decoration-none">${safeDisplayName}</a>`
      : safeDisplayName;
    tr.innerHTML = `
      <td>${fileCellContent}</td>
      <td>
        <span class="badge bg-${getStatusBadgeClass(selection.status)}">
          ${selectionStatusLabels[selection.status] || selection.status}
        </span>
      </td>
      <td>${selection.attempts}</td>
      <td><small class="text-danger">${selection.error || ''}</small></td>
    `;
    return tr;
  }

  function buildEmptyMessage(sessionStatus) {
    if (sessionStatus === 'processing') {
      return '<i class="bi bi-clock"></i> Celery処理待ち中...';
    }
    if (sessionStatus === 'ready') {
      return '<i class="bi bi-info-circle"></i> 対象ファイルがありません';
    }
    if (sessionStatus === 'imported') {
      return '<i class="bi bi-check-circle"></i> 処理完了（対象ファイル: 0件）';
    }
    if (sessionStatus === 'error') {
      return '<i class="bi bi-exclamation-triangle text-danger"></i> 処理エラー';
    }
    return '<i class="bi bi-info-circle"></i> 対象ファイルがありません';
  }

  function updateCountsDisplay(counts, sessionStatus) {
    if (counts && Object.keys(counts).length > 0) {
      if (hasOnlyDuplicates(counts)) {
        const dupTotal = duplicateCount(counts);
        const duplicateLabel = selectionStatusLabels.dup || 'Duplicate';
        countsEl.textContent = `${duplicateLabel}: ${dupTotal}`;
      } else {
        countsEl.textContent = formatCounts(counts);
      }
      return;
    }

    if (sessionStatus === 'processing') {
      countsEl.textContent = 'ステータス: 処理待ち';
    } else if (sessionStatus === 'ready') {
      countsEl.textContent = '選択されたファイル: 0件';
    } else if (sessionStatus === 'imported') {
      countsEl.textContent = '処理完了: 0件';
    } else if (sessionStatus === 'error') {
      countsEl.textContent = 'ステータス: エラー';
    } else {
      countsEl.textContent = '選択されたファイル: 0件';
    }
  }

  function updateImportButtonState(sessionData) {
    if (!sessionData) return;
    if (sessionData.isLocalImport) {
      importBtn.style.display = 'none';
      importBtn.disabled = true;
      importBtn.classList.add('disabled');
      importBtn.setAttribute('aria-disabled', 'true');
      return;
    }

    importBtn.style.display = '';
    const canImport = sessionData.status === 'ready';
    importBtn.disabled = !canImport;
    importBtn.classList.toggle('disabled', !canImport);
    importBtn.setAttribute('aria-disabled', (!canImport).toString());
  }

  function updateLocalImportControls(sessionData) {
    if (!stopLocalImportBtn || !localImportStatusEl) {
      return;
    }

    stopLocalImportBtn.classList.add('d-none');
    stopLocalImportBtn.disabled = true;
    stopLocalImportBtn.setAttribute('aria-disabled', 'true');
    localImportStatusEl.classList.add('d-none');
    localImportStatusEl.classList.remove('text-warning', 'text-danger', 'text-success');
    localImportStatusEl.classList.add('text-muted');
    localImportStatusEl.textContent = '';

    if (!sessionData || !sessionData.isLocalImport) {
      return;
    }

    const cancellableStatuses = ['expanding', 'processing', 'importing', 'enqueued'];
    const stats = sessionData.stats || {};
    const cancelRequested = Boolean(stats.cancel_requested);
    const displayStatus = sessionData.status;

    localImportStatusEl.classList.remove('d-none');

    if (displayStatus === 'canceled') {
      localImportStatusEl.textContent = localImportCanceledMessage;
      localImportStatusEl.classList.remove('text-muted');
      localImportStatusEl.classList.add('text-danger');
      return;
    }

    if (cancelRequested) {
      localImportStatusEl.textContent = localImportCancelingMessage;
      localImportStatusEl.classList.remove('text-muted');
      localImportStatusEl.classList.add('text-warning');
      return;
    }

    if (cancellableStatuses.includes(displayStatus)) {
      localImportStatusEl.textContent = localImportRunningMessage;
      stopLocalImportBtn.classList.remove('d-none');
      stopLocalImportBtn.disabled = false;
      stopLocalImportBtn.setAttribute('aria-disabled', 'false');
      return;
    }

    localImportStatusEl.textContent = '{{ _("Local import session runs automatically.") }}';
  }

  function updateSessionInfo(sessionData) {
    if (!sessionData) {
      return;
    }

    if (sessionTitleEl) {
      sessionTitleEl.textContent = sessionData.isLocalImport
        ? '{{ _("Local Import Session") }}'
        : '{{ _("Session Details") }}';
    }

    if (sessionSubtitleEl) {
      const subtitleParts = [];
      if (sessionData.sessionId) {
        subtitleParts.push(sessionData.sessionId);
      }
      if (!sessionData.isLocalImport && sessionData.accountEmail) {
        subtitleParts.push(sessionData.accountEmail);
      }
      sessionSubtitleEl.textContent = subtitleParts.join(' • ');
      sessionSubtitleEl.classList.toggle('d-none', subtitleParts.length === 0);
    }

    const stats = sessionData.stats || {};
    const accountLabel = sessionData.isLocalImport
      ? '{{ _("Local Import") }}'
      : (sessionData.accountEmail || '-');
    const selectedCount = deriveSelectedCount(sessionData);
    const countsSummary = formatCounts(sessionData.counts) || '-';
    const createdAt = formatDateTime(sessionData.createdAt);
    const lastProgress = formatDateTime(sessionData.lastProgressAt);
    const statusLabel = sessionStatusLabels[sessionData.status] || sessionData.status || '-';
    const statusBadge = `<span class="badge bg-${getSessionBadgeClass(sessionData.status)}">${statusLabel}</span>`;

    const infoParts = [];
    infoParts.push(`<div><strong>{{ _("Status") }}:</strong> ${statusBadge}</div>`);

    if (sessionData.isLocalImport) {
      const stageValue = stats.stage;
      if (typeof stageValue === 'string' && stageValue.trim().length > 0) {
        const normalizedStage = stageValue.trim().toLowerCase();
        const stageLabel = sessionStageLabels[normalizedStage] || sessionStatusLabels[normalizedStage] || stageValue;
        infoParts.push(`<div><strong>{{ _("Current Stage") }}:</strong> ${escapeHtml(stageLabel)}</div>`);
      }
    }

    infoParts.push(`<div><strong>{{ _("Target Account") }}:</strong> ${accountLabel}</div>`);
    infoParts.push(`<div><strong>{{ _("Selected Files") }}:</strong> ${selectedCount}</div>`);
    infoParts.push(`<div><strong>{{ _("File Status") }}:</strong> ${countsSummary}</div>`);
    infoParts.push(`<div><strong>{{ _("Created At") }}:</strong> ${createdAt}</div>`);
    infoParts.push(`<div><strong>{{ _("Last Progress") }}:</strong> ${lastProgress}</div>`);

    if (sessionData.isLocalImport) {
      if (sessionData.status === 'canceled') {
        infoParts.push(`<div class="mt-2 text-muted"><i class="bi bi-x-circle"></i> {{ _("Local import was canceled.") }}</div>`);
      } else if (stats.cancel_requested) {
        infoParts.push(`<div class="mt-2 text-warning"><i class="bi bi-hourglass-split"></i> {{ _("Canceling local import...") }}</div>`);
      } else {
        infoParts.push(`<div class="mt-2 text-muted"><i class="bi bi-info-circle"></i> {{ _("Local Import Session. Import runs automatically.") }}</div>`);
      }
    } else if (sessionData.status !== 'ready') {
      infoParts.push(`<div class="mt-2 text-warning"><i class="bi bi-exclamation-triangle"></i> {{ _("Import can only be started when the session status is ready.") }}</div>`);
    }

    sessionInfoEl.innerHTML = infoParts.join('');
    updateLocalImportControls(sessionData);
  }

  async function withBusy(btn, fn) {
    const originalHtml = btn.innerHTML;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> {{ _("Working...") }}';
    btn.disabled = true;
    btn.setAttribute('aria-busy', 'true');
    try {
      return await fn();
    } finally {
      btn.innerHTML = originalHtml;
      btn.disabled = false;
      btn.removeAttribute('aria-busy');
    }
  }

  async function fetchSessionStatus() {
    try {
      const resp = await window.apiClient.get(`/api/picker/session/${encodeURIComponent(pickerSessionId)}`);
      if (resp.status === 404) {
        window.location.href = '/photo-view';
        return null;
      }
      if (resp.status === 401 || resp.status === 302) {
        window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname + window.location.search);
        return null;
      }
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}`);
      }

      const data = await resp.json();
      data.counts = data.counts || {};
      data.status = determineDisplayStatus(data);
      isLocalImport = Boolean(data.isLocalImport);
      updateImportButtonState(data);
      updateSessionInfo(data);
      return data;
    } catch (error) {
      console.warn('Failed to fetch session status:', error);
      return null;
    }
  }

  async function fetchSessionLogs() {
    if (!pickerSessionId) {
      return;
    }

    if (!isLocalImport) {
      renderLocalImportLogs([], false);
      return;
    }

    try {
      const resp = await window.apiClient.get(`/api/picker/session/${encodeURIComponent(pickerSessionId)}/logs?limit=50`);
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}`);
      }

      const payload = await resp.json().catch(() => ({}));
      renderLocalImportLogs(payload.logs || [], true);
    } catch (error) {
      console.warn('Failed to fetch session logs:', error);
    }
  }

  async function stopLocalImportSession() {
    if (!pickerSessionId || !stopLocalImportBtn) {
      return;
    }

    await withBusy(stopLocalImportBtn, async () => {
      try {
        const resp = await window.apiClient.post(`/api/sync/local-import/${encodeURIComponent(pickerSessionId)}/stop`);

        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          console.error('Failed to stop local import:', resp.status, text);
          statusEl.textContent = localImportStopFailedMessage;
          showErrorToast(localImportStopFailedMessage);
          return;
        }

        const payload = await resp.json().catch(() => ({}));
        const message = (payload && payload.message) ? payload.message : localImportCanceledMessage;
        statusEl.textContent = message;
        showInfoToast(message, 4000);
        await fetchSessionStatus();
        await refreshSelections();
      } catch (error) {
        console.error('Stop local import failed:', error);
        statusEl.textContent = localImportStopFailedMessage;
        showErrorToast(localImportStopFailedMessage);
      }
    });
  }

  async function refreshSelections() {
    if (isRefreshing) {
      return;
    }
    isRefreshing = true;
    try {
      const sessionData = await fetchSessionStatus();
      latestStatus = sessionData?.status || latestStatus;
      currentCounts = sessionData?.counts || currentCounts || {};
      updateCountsDisplay(currentCounts, latestStatus);

      if (sessionData && sessionData.isLocalImport) {
        await fetchSessionLogs();
      } else {
        renderLocalImportLogs([], false);
      }

      if (!paginationClient) {
        paginationClient = new PaginationClient({
          baseUrl: `/api/picker/session/${encodeURIComponent(pickerSessionId)}/selections`,
          pageSize: 200,
          autoLoad: false,
          onItemsLoaded: (items, meta) => {
            if (meta.currentPage === 1) {
              selectionBody.innerHTML = '';
            }

            if (items.length === 0 && meta.currentPage === 1) {
              const tr = document.createElement('tr');
              tr.innerHTML = `
                <td colspan="4" class="text-center text-muted py-4">
                  ${buildEmptyMessage(latestStatus)}
                </td>
              `;
              selectionBody.appendChild(tr);
            } else {
              items.forEach(selection => {
                const row = createSelectionRow(selection);
                selectionBody.appendChild(row);
              });
            }
          },
          onError: (error) => {
            console.error('Selection loading error:', error);
          }
        });
      }

      await paginationClient.loadFirst();
    } catch (err) {
      console.error(err);
    } finally {
      isRefreshing = false;
    }
  }

  if (stopLocalImportBtn) {
    stopLocalImportBtn.addEventListener('click', () => {
      stopLocalImportSession();
    });
  }

  importBtn.addEventListener('click', async () => {
    if (!pickerSessionId) return;

    if (importBtn.disabled) {
      if (isLocalImport) {
        statusEl.textContent = 'ローカルインポートセッションでは手動インポートできません。';
      } else {
        statusEl.textContent = '{{ _("Import is not available for the current status.") }}';
      }
      return;
    }

    await withBusy(importBtn, async () => {
      try {
        const resp = await window.apiClient.post(`/api/picker/session/${encodeURIComponent(pickerSessionId)}/import`);

        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          console.error('Import start failed:', resp.status, text);
          statusEl.textContent = '{{ _("Failed to start import.") }}';
          showErrorToast('{{ _("Failed to start import.") }}');
          return;
        }

        statusEl.textContent = '{{ _("Import started.") }}';
        showSuccessToast('{{ _("Import started.") }}');
        refreshSelections();
      } catch (err) {
        console.error(err);
        statusEl.textContent = '{{ _("Failed to start import.") }}';
        showErrorToast('{{ _("Failed to start import.") }}');
      }
    });
  });

  setInterval(refreshSelections, 3000);
  refreshSelections();
});
</script>
{% endblock %}