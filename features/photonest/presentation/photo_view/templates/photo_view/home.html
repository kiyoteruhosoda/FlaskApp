{% extends 'base.html' %}
{% block title %}Photo View{% endblock %}

{% block extra_head %}
<script src="{{ url_for('static', filename='js/pagination.js') }}"></script>
<style>
  #sessions-list .session-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: flex-start;
  }

  .quick-actions-card {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .quick-actions-grid {
    display: grid;
    gap: 0.75rem;
  }

  .quick-actions-grid > * {
    width: 100%;
  }

  .quick-actions-grid .quick-actions-full {
    grid-column: 1 / -1;
  }

  .quick-actions-panel {
    border: 1px solid var(--bs-border-color-translucent);
    border-radius: var(--bs-border-radius);
    padding: 1rem;
    background-color: var(--bs-tertiary-bg);
  }

  .upload-dropzone {
    border: 2px dashed var(--bs-border-color-translucent);
    border-radius: var(--bs-border-radius);
    padding: 2rem 1rem;
    text-align: center;
    transition: background-color 0.2s ease, border-color 0.2s ease;
    cursor: pointer;
  }

  .upload-dropzone.drag-over {
    background-color: rgba(var(--bs-primary-rgb), 0.05);
    border-color: rgba(var(--bs-primary-rgb), 0.4);
  }

  .upload-file-list {
    max-height: 240px;
    overflow-y: auto;
  }

  .upload-summary-text {
    font-size: 0.875rem;
  }

  .upload-status-badge {
    font-size: 0.75rem;
  }

  @media (min-width: 992px) {
    .quick-actions-grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      align-items: stretch;
    }

    .quick-actions-grid .quick-action-compact {
      min-height: 3rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
  }

  .session-starter {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .session-starter .input-group {
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .session-starter .input-group > * {
    flex: 1 1 auto;
  }

  .session-starter .input-group > .btn {
    flex: 0 1 auto;
    white-space: nowrap;
  }

  @media (min-width: 768px) {
    .session-starter .input-group {
      flex-wrap: nowrap;
      gap: 0;
    }
  }

</style>
{% endblock %}

{% block content %}
<div class="photo-view-home container-xxl px-3 px-md-4 px-xxl-5 mx-auto">
  <div class="d-flex flex-wrap justify-content-between align-items-start gap-3 mb-4">
    <div>
      <h1 class="h2 mb-1">{{ _("Photo View Home") }}</h1>
      <p class="text-muted mb-0">{{ _("Create new picker sessions and keep track of imports at a glance.") }}</p>
    </div>
    <div class="d-flex flex-wrap align-items-center gap-2">
      {% if is_admin %}
        <span class="badge bg-warning text-dark d-flex align-items-center px-3 py-2">
          <i class="bi bi-tools me-1"></i>{{ _("Admin tools available") }}
        </span>
      {% endif %}
      <a href="{{ url_for('photo_view.settings') }}" class="btn btn-outline-secondary">
        <i class="bi bi-gear me-1"></i>{{ _("Settings") }}
      </a>
    </div>
  </div>

  <div class="row g-3 align-items-stretch mb-4">
    <div class="col-xl-7">
      <div class="card shadow-sm h-100">
        <div class="card-header bg-white">
          <h2 class="h5 mb-0">{{ _("Start a new picker session") }}</h2>
        </div>
        <div class="card-body session-starter">
          <label for="session-account" class="form-label">{{ _("Google account for the new session") }}</label>
          <div class="input-group">
            {% set has_multiple_accounts = google_accounts|length > 1 %}
            <select id="session-account" class="form-select" {% if not google_accounts %}disabled{% endif %}>
              {% if not google_accounts %}
                <option value="" selected disabled>{{ _("No Google accounts are linked yet") }}</option>
              {% else %}
                <option value="" disabled {% if has_multiple_accounts %}selected{% endif %}>{{ _("Select an account") }}</option>
                {% for account in google_accounts %}
                  <option value="{{ account.id }}" {% if not has_multiple_accounts and loop.first %}selected{% endif %}>{{ account.email }}</option>
                {% endfor %}
              {% endif %}
            </select>
            <button id="create-session-btn" class="btn btn-success" {% if not google_accounts %}disabled{% endif %}>
              <i class="bi bi-plus-circle me-1"></i>{{ _("Create new session") }}
            </button>
          </div>
          {% if not google_accounts %}
            <div class="form-text text-muted mt-2">
              {{ _("Link a Google account from the admin console before creating a new session.") }}
            </div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="col-xl-5">
      <div class="card shadow-sm h-100">
        <div class="card-header bg-white d-flex justify-content-between align-items-center">
          <h2 class="h6 mb-0">{{ _("Quick actions") }}</h2>
          <span class="text-muted small">{{ _("Everything you need for day-to-day work") }}</span>
        </div>
        <div class="card-body quick-actions-card">
          <div class="quick-actions-grid">
            <button id="refresh-sessions" class="btn btn-outline-primary quick-action-compact quick-actions-full">
              <i id="refresh-icon" class="fas fa-arrows-rotate me-2"></i>{{ _("Refresh sessions") }}
            </button>
            <button type="button" id="open-upload-modal" class="btn btn-outline-secondary quick-action-compact">
              <i class="bi bi-upload me-2"></i>{{ _("Upload files") }}
            </button>
            {% if is_admin %}
              <div class="quick-actions-panel quick-actions-full">
                <div class="fw-semibold small mb-1">{{ _("Duplicate handling") }}</div>
                <p class="text-muted small mb-2">{{ _("Choose how duplicate videos should refresh their thumbnails and playback assets during import.") }}</p>
                <div class="form-check">
                  <input class="form-check-input" type="radio" name="duplicate-regeneration" id="duplicate-regenerate" value="regenerate" checked>
                  <label class="form-check-label" for="duplicate-regenerate">
                    {{ _("Regenerate thumbnails and playback assets") }}
                  </label>
                  <div class="form-text">{{ _("Always recreate thumbnails and playback MP4 files even when they already exist.") }}</div>
                </div>
                <div class="form-check mt-2">
                  <input class="form-check-input" type="radio" name="duplicate-regeneration" id="duplicate-skip" value="skip">
                  <label class="form-check-label" for="duplicate-skip">
                    {{ _("Keep existing assets for duplicates") }}
                  </label>
                  <div class="form-text">{{ _("Skip regeneration when the duplicate already has thumbnails and playback assets.") }}</div>
                </div>
              </div>
            {% endif %}
            <button type="button" id="local-import-btn" class="btn btn-outline-info quick-action-compact"
                    data-import-display="{{ local_import_info.import.display or '' }}"
                    data-import-absolute="{{ local_import_info.import.absolute or '' }}"
                    data-import-realpath="{{ local_import_info.import.realpath or '' }}"
                    data-import-exists="{{ '1' if local_import_info.import.exists else '0' }}"
                    data-destination-display="{{ local_import_info.originals.display or '' }}"
                    data-destination-absolute="{{ local_import_info.originals.absolute or '' }}"
                    data-destination-realpath="{{ local_import_info.originals.realpath or '' }}"
                    data-destination-exists="{{ '1' if local_import_info.originals.exists else '0' }}">
              <i class="bi bi-folder-plus me-2"></i>{{ _("Start local import") }}
            </button>
            <a href="{{ url_for('photo_view.media_list') }}" class="btn btn-primary quick-action-compact">
              <i class="fas fa-images me-2"></i>{{ _("Open media gallery") }}
            </a>
            <a href="{{ url_for('photo_view.albums') }}" class="btn btn-outline-success quick-action-compact">
              <i class="fas fa-folder me-2"></i>{{ _("Browse albums") }}
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

  {% if local_import_info.import.display %}
    <div class="alert alert-light border small" role="status">
      <div class="fw-semibold mb-1">{{ _("Local import paths") }}</div>
      <div>
        {{ _("Local import source") }}:
        <code>{{ local_import_info.import.display }}</code>
        {% if local_import_info.import.absolute and local_import_info.import.absolute != local_import_info.import.display %}
          <span class="ms-1">({{ _("Configured value") }}: <code>{{ local_import_info.import.absolute }}</code>)</span>
        {% elif local_import_info.import.raw and local_import_info.import.raw != local_import_info.import.display %}
          <span class="ms-1">({{ _("Configured value") }}: <code>{{ local_import_info.import.raw }}</code>)</span>
        {% endif %}
        {% if not local_import_info.import.exists %}
          <span class="ms-1 text-danger">{{ _("Not found") }}</span>
        {% endif %}
      </div>
      <div class="mt-1">
        {{ _("Destination") }}:
        {% if local_import_info.originals.display %}
          <code>{{ local_import_info.originals.display }}</code>
          {% if local_import_info.originals.absolute and local_import_info.originals.absolute != local_import_info.originals.display %}
            <span class="ms-1">({{ _("Configured value") }}: <code>{{ local_import_info.originals.absolute }}</code>)</span>
          {% elif local_import_info.originals.raw and local_import_info.originals.raw != local_import_info.originals.display %}
            <span class="ms-1">({{ _("Configured value") }}: <code>{{ local_import_info.originals.raw }}</code>)</span>
          {% endif %}
          {% if not local_import_info.originals.exists %}
            <span class="ms-1 text-danger">{{ _("Not found") }}</span>
          {% endif %}
        {% else %}
          <span class="text-warning">{{ _("No destination directory configured.") }}</span>
        {% endif %}
      </div>
    </div>
  {% endif %}

  <div class="mt-4">
    <h2 data-i18n-key="All Picker Sessions">{{ _("All Picker Sessions") }}</h2>
    <div id="session-stats" class="mb-3">
      <span id="session-count" class="badge bg-info">{{ _("Loading...") }}</span>
    </div>
    <div id="sessions-list">
      <div class="table-responsive">
        <table class="table table-striped">
          <thead>
            <tr>
              <th>{{ _("Session ID") }}</th>
              <th>{{ _("Status") }}</th>
              <th>{{ _("Target Account") }}</th>
              <th>{{ _("File Status") }}</th>
              <th>{{ _("Created At") }}</th>
              <th>{{ _("Last Progress") }}</th>
              <th>{{ _("Actions") }}</th>
            </tr>
          </thead>
          <tbody id="sessions-body">
            <!-- Sessions will be added dynamically -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="loading-indicator" class="text-center" style="display: none;">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">{{ _("Loading...") }}</span>
    </div>
    <p class="mt-2">{{ _("Loading more sessions...") }}</p>
  </div>

  <div id="no-more-data" class="text-center text-muted" style="display: none;">
    <p>{{ _("All sessions loaded") }}</p>
  </div>
</div>

<div class="modal fade" id="upload-modal" tabindex="-1" aria-labelledby="upload-modal-title" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="upload-modal-title">{{ _("Upload files") }}</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="{{ _("Close") }}"></button>
      </div>
      <div class="modal-body">
        <div id="upload-status-message" class="alert alert-info d-none" role="status"></div>
        <div id="upload-dropzone" class="upload-dropzone mb-3">
          <div class="fw-semibold mb-1">{{ _("Drag & drop files here") }}</div>
          <div class="text-muted small mb-0">{{ _("You can also click to choose files manually.") }}</div>
        </div>
        <label for="upload-file-input" class="form-label">{{ _("Select files") }}</label>
        <input type="file" id="upload-file-input" class="form-control" multiple>
        <div class="table-responsive mt-3 border rounded">
          <table class="table table-sm align-middle mb-0">
            <thead>
              <tr>
                <th>{{ _("File") }}</th>
                <th class="text-end">{{ _("Size") }}</th>
                <th>{{ _("Status") }}</th>
                <th class="text-end">{{ _("Actions") }}</th>
              </tr>
            </thead>
            <tbody id="upload-file-list" class="upload-file-list">
              <tr class="text-muted text-center">
                <td colspan="4">{{ _("Drop files above to start analysis.") }}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" id="upload-clear-btn">{{ _("Cancel") }}</button>
        <button type="button" class="btn btn-primary" id="upload-commit-btn" disabled>{{ _("Upload") }}</button>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const sessionsBody = document.getElementById('sessions-body');
  const loadingIndicator = document.getElementById('loading-indicator');
  const noMoreData = document.getElementById('no-more-data');
  const refreshBtn = document.getElementById('refresh-sessions');
  const sessionCount = document.getElementById('session-count');
  const createSessionBtn = document.getElementById('create-session-btn');
  const accountSelect = document.getElementById('session-account');
  const localImportBtn = document.getElementById('local-import-btn');
  const duplicateModeRadios = document.querySelectorAll('input[name="duplicate-regeneration"]');
  const isAdmin = {{ 'true' if is_admin else 'false' }};

  const uploadModalTrigger = document.getElementById('open-upload-modal');
  const uploadModalElement = document.getElementById('upload-modal');
  const uploadStatusMessage = document.getElementById('upload-status-message');
  const uploadFileList = document.getElementById('upload-file-list');
  const uploadFileInput = document.getElementById('upload-file-input');
  const uploadCommitBtn = document.getElementById('upload-commit-btn');
  const uploadClearBtn = document.getElementById('upload-clear-btn');
  const uploadDropzone = document.getElementById('upload-dropzone');

  function resolveBootstrapModal(element) {
    if (!element) {
      return null;
    }

    const bootstrapNamespace = window.bootstrap || (typeof bootstrap !== 'undefined' ? bootstrap : null);
    if (!bootstrapNamespace) {
      console.warn('Bootstrap modal namespace not found. Upload dialog will not be interactive.');
      return null;
    }

    const modalCtor = bootstrapNamespace.Modal
      || (bootstrapNamespace.default && bootstrapNamespace.default.Modal)
      || null;

    if (!modalCtor) {
      console.warn('Bootstrap modal constructor not available. Upload dialog will not be interactive.');
      return null;
    }

    if (typeof modalCtor.getOrCreateInstance === 'function') {
      return modalCtor.getOrCreateInstance(element);
    }

    if (typeof modalCtor === 'function') {
      return new modalCtor(element);
    }

    console.warn('Bootstrap modal constructor is not invocable. Upload dialog will not be interactive.');
    return null;
  }

  const uploadModal = resolveBootstrapModal(uploadModalElement);

  const selectAccountMessage = '{{ _("Please choose a Google account first.") }}';
  const localImportPromptHeader = '{{ _("Start a local import from the following directories?") }}';
  const localImportSourceLabel = '{{ _("Source") }}';
  const localImportDestinationLabel = '{{ _("Destination") }}';
  const localImportResolvedLabel = '{{ _("Resolved path") }}';
  const localImportMissingLabel = '{{ _("Not found") }}';
  const localImportRemovalNotice = '{{ _("Files will be removed from the original directory after import completes.") }}';
  const localImportDestinationUnset = '{{ _("No destination directory configured.") }}';
  const localImportStartingNotice = '{{ _("Starting local import...") }}';
  const localImportSuccessNotice = '{{ _("Local import has started. Track the progress in the session list.") }}';
  const localImportErrorNotice = '{{ _("Failed to start the local import.") }}';
  const startingImportNotice = '{{ _("Starting import...") }}';
  const localImportStopStartingNotice = '{{ _("Canceling local import...") }}';
  const localImportStopSuccessNotice = '{{ _("Local import was canceled.") }}';
  const localImportStopErrorNotice = '{{ _("Failed to stop local import.") }}';
  const localImportCancelConfirmMessage = '{{ _("Are you sure you want to cancel the local import?") }}';
  const stopLocalImportLabel = '{{ _("Stop Local Import") }}';
  const localImportRunningMessage = '{{ _("Local import is running. You can stop it if needed.") }}';
  const duplicateModeSummaryLabel = '{{ _("Duplicate handling") }}';
  const duplicateModeRegenerateLabel = '{{ _("Regenerate thumbnails and playback assets") }}';
  const duplicateModeSkipLabel = '{{ _("Keep existing assets for duplicates") }}';
  const duplicateModeRegenerateDescription = '{{ _("Always recreate thumbnails and playback MP4 files even when they already exist.") }}';
  const duplicateModeSkipDescription = '{{ _("Skip regeneration when the duplicate already has thumbnails and playback assets.") }}';

  const uploadStatusLabels = {
    pending: '{{ _("Waiting") }}',
    analyzing: '{{ _("Analyzing") }}',
    analyzed: '{{ _("Analysis complete") }}',
    uploaded: '{{ _("Uploaded") }}',
    error: '{{ _("Error") }}',
  };
  const uploadStatusBadgeClasses = {
    pending: 'bg-secondary',
    analyzing: 'bg-warning text-dark',
    analyzed: 'bg-info',
    uploaded: 'bg-success',
    error: 'bg-danger',
  };
  const uploadAnalysisPendingLabel = '{{ _("Waiting for analysis to start.") }}';
  const uploadAnalyzingLabel = '{{ _("Analyzing file...") }}';
  const uploadFormatLabel = '{{ _("Format") }}';
  const uploadRecordsLabel = '{{ _("Records") }}';
  const uploadLinesLabel = '{{ _("Lines") }}';
  const uploadInvalidJsonLabel = '{{ _("Invalid JSON data") }}';
  const uploadErrorGeneric = '{{ _("Failed to prepare the file.") }}';
  const uploadNetworkError = '{{ _("Network error occurred while preparing the file.") }}';
  const uploadCommitSuccessMessage = '{{ _("Upload completed successfully.") }}';
  const uploadCommitPartialMessage = '{{ _("Some files could not be uploaded.") }}';
  const uploadNoReadyFilesMessage = '{{ _("No analyzed files are ready for upload.") }}';
  const uploadClearedMessage = '{{ _("Upload list cleared.") }}';
  const uploadUploadingMessage = '{{ _("Uploading files...") }}';
  const uploadRemoveLabel = '{{ _("Remove") }}';
  const uploadDropPlaceholder = '{{ _("Drop files above to start analysis.") }}';

  let totalLoaded = 0;
  const sessionsLoadedLabel = '{{ _("sessions loaded") }}';
  const noSessionsLoadedLabel = '{{ _("No sessions loaded yet") }}';

  function formatDateTime(isoString) {
    if (!isoString) return '-';
    const helper = window.appTime;
    if (helper && typeof helper.formatDateTime === 'function') {
      const formatted = helper.formatDateTime(isoString);
      return formatted || '-';
    }
    const date = new Date(isoString);
    return Number.isNaN(date.getTime()) ? '-' : date.toLocaleString();
  }

  const selectionStatusLabels = {
    pending: '{{ _("Pending") }}',
    enqueued: '{{ _("Enqueued") }}',
    running: '{{ _("Running") }}',
    imported: '{{ _("Imported") }}',
    failed: '{{ _("Failed") }}',
    dup: '{{ _("Duplicate") }}',
    skipped: '{{ _("Skipped") }}'
  };

  const sessionStatusLabels = {
    pending: '{{ _("Pending") }}',
    ready: '{{ _("Ready") }}',
    expanding: '{{ _("Expanding") }}',
    processing: '{{ _("Processing") }}',
    enqueued: '{{ _("Enqueued") }}',
    importing: '{{ _("Importing") }}',
    imported: '{{ _("Imported") }}',
    canceled: '{{ _("Canceled") }}',
    expired: '{{ _("Expired") }}',
    error: '{{ _("Error") }}',
    failed: '{{ _("Failed") }}'
  };

  function formatCounts(counts) {
    if (!counts || Object.keys(counts).length === 0) return '-';
    return Object.entries(counts)
      .map(([status, count]) => `${selectionStatusLabels[status] || status}: ${count}`)
      .join(', ');
  }

  function formatAccountLabel(session) {
    if (session.isLocalImport) {
      return '{{ _("Local Import") }}';
    }
    if (session.accountEmail) {
      return session.accountEmail;
    }
    return '-';
  }

  function normalizeDuplicateMode(value) {
    if (typeof value !== 'string') {
      return 'regenerate';
    }
    return value.toLowerCase() === 'skip' ? 'skip' : 'regenerate';
  }

  function getSelectedDuplicateMode() {
    let selected = 'regenerate';
    duplicateModeRadios.forEach((radio) => {
      if (radio.checked) {
        selected = normalizeDuplicateMode(radio.value);
      }
    });
    return selected;
  }

  function describeDuplicateMode(mode) {
    const normalized = normalizeDuplicateMode(mode);
    if (normalized === 'skip') {
      return {
        label: duplicateModeSkipLabel,
        description: duplicateModeSkipDescription,
      };
    }
    return {
      label: duplicateModeRegenerateLabel,
      description: duplicateModeRegenerateDescription,
    };
  }

  function getStatusBadgeClass(status) {
    switch (status) {
      case 'pending': return 'secondary';
      case 'ready': return 'primary';
      case 'expanding': return 'warning';
      case 'processing': return 'warning';
      case 'importing': return 'info';
      case 'imported': return 'success';
      case 'expired': return 'danger';
      case 'error': return 'danger';
      default: return 'secondary';
    }
  }

  const uploadItems = new Map();
  let uploadSequence = 0;

  function escapeHtml(str) {
    if (str == null) {
      return '';
    }
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function formatBytes(bytes) {
    const numeric = Number(bytes);
    if (!Number.isFinite(numeric) || numeric < 0) {
      return '-';
    }
    if (numeric === 0) {
      return '0 B';
    }
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    const exponent = Math.min(Math.floor(Math.log(numeric) / Math.log(1024)), units.length - 1);
    const value = numeric / (1024 ** exponent);
    const decimals = exponent === 0 ? 0 : 1;
    return `${value.toFixed(decimals)} ${units[exponent]}`;
  }

  function setUploadStatus(level, message) {
    if (!uploadStatusMessage) {
      return;
    }
    uploadStatusMessage.className = 'alert';
    uploadStatusMessage.classList.add('d-none');
    if (!message) {
      uploadStatusMessage.textContent = '';
      return;
    }

    const levelClass = {
      success: 'alert-success',
      error: 'alert-danger',
      warning: 'alert-warning',
      info: 'alert-info',
    }[level || 'info'] || 'alert-info';

    uploadStatusMessage.classList.add(levelClass);
    uploadStatusMessage.textContent = message;
    uploadStatusMessage.classList.remove('d-none');
  }

  function resetUploadStatus() {
    setUploadStatus(null, '');
  }

  function buildAnalysisSummary(item) {
    if (item.status === 'analyzing') {
      return escapeHtml(uploadAnalyzingLabel);
    }
    if (!item.analysisResult) {
      if (item.status === 'pending') {
        return escapeHtml(uploadAnalysisPendingLabel);
      }
      if (item.status === 'error' && item.message) {
        return escapeHtml(item.message);
      }
      return '';
    }
    const summaryParts = [];
    const analysis = item.analysisResult;
    if (analysis.format) {
      summaryParts.push(`${uploadFormatLabel}: ${analysis.format}`);
    }
    if (typeof analysis.recordCount === 'number') {
      summaryParts.push(`${uploadRecordsLabel}: ${analysis.recordCount}`);
    }
    if (
      typeof analysis.lineCount === 'number'
      && analysis.lineCount !== analysis.recordCount
      && analysis.lineCount > 0
    ) {
      summaryParts.push(`${uploadLinesLabel}: ${analysis.lineCount}`);
    }
    if (analysis.valid === false) {
      summaryParts.push(uploadInvalidJsonLabel);
    }
    return summaryParts.map((part) => escapeHtml(part)).join(' Â· ');
  }

  function renderUploadRows() {
    if (!uploadFileList) {
      return;
    }

    uploadFileList.innerHTML = '';

    if (uploadItems.size === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.className = 'text-muted text-center';
      emptyRow.innerHTML = `<td colspan="4">${escapeHtml(uploadDropPlaceholder)}</td>`;
      uploadFileList.appendChild(emptyRow);
      return;
    }

    uploadItems.forEach((item) => {
      const row = document.createElement('tr');
      row.dataset.uploadId = item.id;
      const statusKey = item.status || 'pending';
      const badgeClass = uploadStatusBadgeClasses[statusKey] || 'bg-secondary';
      const statusLabel = uploadStatusLabels[statusKey] || statusKey;
      const summary = buildAnalysisSummary(item);
      const messageHtml = item.message
        ? `<div class="small mt-1 ${item.status === 'error' ? 'text-danger' : 'text-success'}">${escapeHtml(item.message)}</div>`
        : '';

      row.innerHTML = `
        <td>
          <div class="fw-semibold">${escapeHtml(item.file?.name || item.serverFileName || '-')}</div>
          ${summary ? `<div class="text-muted upload-summary-text mt-1">${summary}</div>` : ''}
        </td>
        <td class="text-end">${formatBytes(item.file?.size ?? item.serverFileSize ?? 0)}</td>
        <td>
          <span class="badge ${badgeClass} upload-status-badge">${escapeHtml(statusLabel)}</span>
          ${messageHtml}
        </td>
        <td class="text-end">
          <button type="button" class="btn btn-sm btn-link text-danger p-0" data-remove-upload="${escapeHtml(item.id)}">
            <i class="bi bi-x-circle me-1"></i>${escapeHtml(uploadRemoveLabel)}
          </button>
        </td>
      `;
      uploadFileList.appendChild(row);
    });
  }

  function updateUploadControls() {
    if (!uploadCommitBtn || !uploadClearBtn) {
      return;
    }
    const hasReady = Array.from(uploadItems.values()).some((item) => item.status === 'analyzed' && item.tempFileId);
    uploadCommitBtn.disabled = !hasReady;
    uploadClearBtn.disabled = uploadItems.size === 0;
  }

  function findUploadEntryByTempId(tempFileId) {
    for (const [key, value] of uploadItems.entries()) {
      if (value.tempFileId === tempFileId) {
        return [key, value];
      }
    }
    return [null, null];
  }

  function handleFiles(fileList) {
    if (!fileList || fileList.length === 0) {
      return;
    }
    resetUploadStatus();
    Array.from(fileList).forEach((file) => {
      const id = `local-${Date.now()}-${uploadSequence += 1}`;
      const item = {
        id,
        file,
        status: 'pending',
        message: '',
        tempFileId: null,
        analysisResult: null,
        serverFileName: null,
        serverFileSize: file?.size ?? 0,
      };
      uploadItems.set(id, item);
      renderUploadRows();
      updateUploadControls();
      prepareUpload(item).catch((error) => {
        console.error('Failed to prepare upload', error);
      });
    });
  }

  async function prepareUpload(item) {
    item.status = 'analyzing';
    item.message = uploadAnalyzingLabel;
    renderUploadRows();
    updateUploadControls();

    const formData = new FormData();
    formData.append('file', item.file, item.file?.name || 'upload');

    const headers = {};
    if (window.apiClient && typeof window.apiClient.getCsrfTokenFromCookie === 'function') {
      const token = window.apiClient.getCsrfTokenFromCookie();
      if (token) {
        headers['X-CSRFToken'] = token;
      }
    }

    try {
      const response = await fetch('/api/upload/prepare', {
        method: 'POST',
        headers,
        body: formData,
      });

      if (!response.ok) {
        let payload = {};
        try {
          payload = await response.json();
        } catch (err) {
          payload = {};
        }
        item.status = 'error';
        item.message = payload.message || payload.error || uploadErrorGeneric;
        renderUploadRows();
        updateUploadControls();
        return;
      }

      const data = await response.json();
      item.status = data.status || 'analyzed';
      item.tempFileId = data.tempFileId;
      item.serverFileName = data.fileName || item.file?.name;
      item.serverFileSize = data.fileSize ?? item.serverFileSize;
      item.analysisResult = data.analysisResult || null;
      item.message = '';
    } catch (error) {
      console.error('Upload preparation failed', error);
      item.status = 'error';
      item.message = uploadNetworkError;
    }

    renderUploadRows();
    updateUploadControls();
  }

  async function commitUploads() {
    if (!uploadCommitBtn) {
      return;
    }

    const readyItems = Array.from(uploadItems.values()).filter((item) => item.status === 'analyzed' && item.tempFileId);
    if (!readyItems.length) {
      setUploadStatus('warning', uploadNoReadyFilesMessage);
      return;
    }

    uploadCommitBtn.disabled = true;
    setUploadStatus('info', uploadUploadingMessage);

    try {
      const payload = {
        files: readyItems.map((item) => ({ tempFileId: item.tempFileId })),
      };
      const response = await window.apiClient.post('/api/upload/commit', payload);
      let data = {};
      try {
        data = await response.json();
      } catch (err) {
        data = {};
      }

      if (!response.ok) {
        const message = data.message || data.error || uploadErrorGeneric;
        readyItems.forEach((item) => {
          item.status = 'error';
          item.message = message;
        });
        setUploadStatus('error', message);
        return;
      }

      const results = Array.isArray(data.uploaded) ? data.uploaded : [];
      let successCount = 0;
      let errorCount = 0;
      results.forEach((result) => {
        const [key, item] = findUploadEntryByTempId(result.tempFileId);
        if (!item) {
          return;
        }
        if (result.status === 'success') {
          successCount += 1;
          uploadItems.delete(key);
        } else {
          errorCount += 1;
          item.status = 'error';
          item.message = result.message || uploadErrorGeneric;
        }
      });

      if (successCount && !errorCount) {
        renderUploadRows();
        updateUploadControls();
        setUploadStatus('success', uploadCommitSuccessMessage);
        if (uploadModal && typeof uploadModal.hide === 'function') {
          setTimeout(() => uploadModal.hide(), 1200);
        }
        return;
      }

      if (successCount && errorCount) {
        setUploadStatus('warning', uploadCommitPartialMessage);
      } else if (!successCount && errorCount) {
        setUploadStatus('error', uploadCommitPartialMessage);
      } else {
        setUploadStatus('error', uploadErrorGeneric);
      }
    } catch (error) {
      console.error('Upload commit failed', error);
      setUploadStatus('error', uploadNetworkError);
    } finally {
      uploadCommitBtn.disabled = false;
      renderUploadRows();
      updateUploadControls();
    }
  }

  function clearUploads() {
    if (uploadItems.size === 0) {
      return;
    }
    uploadItems.clear();
    renderUploadRows();
    updateUploadControls();
    setUploadStatus('info', uploadClearedMessage);
  }

  if (uploadModalTrigger && uploadModal && typeof uploadModal.show === 'function') {
    uploadModalTrigger.addEventListener('click', () => {
      resetUploadStatus();
      renderUploadRows();
      updateUploadControls();
      uploadModal.show();
    });
  }

  if (uploadClearBtn) {
    uploadClearBtn.addEventListener('click', () => {
      clearUploads();
      if (uploadModal && typeof uploadModal.hide === 'function') {
        uploadModal.hide();
      }
    });
  }

  if (uploadCommitBtn) {
    uploadCommitBtn.addEventListener('click', () => {
      commitUploads();
    });
  }

  if (uploadFileInput) {
    uploadFileInput.addEventListener('change', (event) => {
      handleFiles(event.target.files);
      event.target.value = '';
    });
  }

  if (uploadFileList) {
    uploadFileList.addEventListener('click', (event) => {
      const trigger = event.target.closest('[data-remove-upload]');
      if (!trigger) {
        return;
      }
      event.preventDefault();
      const identifier = trigger.getAttribute('data-remove-upload');
      if (!identifier) {
        return;
      }
      uploadItems.delete(identifier);
      renderUploadRows();
      updateUploadControls();
    });
  }

  if (uploadDropzone) {
    const preventDefaults = (event) => {
      event.preventDefault();
      event.stopPropagation();
    };

    ['dragenter', 'dragover'].forEach((eventName) => {
      uploadDropzone.addEventListener(eventName, (event) => {
        preventDefaults(event);
        uploadDropzone.classList.add('drag-over');
      });
    });

    ['dragleave', 'drop'].forEach((eventName) => {
      uploadDropzone.addEventListener(eventName, (event) => {
        preventDefaults(event);
        if (eventName === 'drop') {
          const files = event.dataTransfer?.files;
          if (files && files.length) {
            handleFiles(files);
          }
        }
        uploadDropzone.classList.remove('drag-over');
      });
    });

    uploadDropzone.addEventListener('click', (event) => {
      event.preventDefault();
      if (uploadFileInput) {
        uploadFileInput.click();
      }
    });
  }

  if (uploadModalElement) {
    uploadModalElement.addEventListener('hidden.bs.modal', () => {
      resetUploadStatus();
    });
  }

  renderUploadRows();
  updateUploadControls();

  function hasOnlyDuplicates(counts = {}) {
    let duplicateTotal = 0;
    let otherTotal = 0;

    Object.entries(counts).forEach(([status, count]) => {
      const numericCount = Number(count) || 0;
      if (status === 'dup') {
        duplicateTotal += numericCount;
        return;
      }
      if (numericCount > 0) {
        otherTotal += numericCount;
      }
    });

    return duplicateTotal > 0 && otherTotal === 0;
  }

  function determineDisplayStatus(session) {
    const baseStatus = session.status;
    if (!baseStatus) {
      return 'pending';
    }

    if (['processing', 'importing', 'error', 'failed'].includes(baseStatus) && hasOnlyDuplicates(session.counts)) {
      return 'imported';
    }

    return baseStatus;
  }

  function createSessionRow(session) {
    const tr = document.createElement('tr');
    const displayStatus = determineDisplayStatus(session);
    const statusLabel = sessionStatusLabels[displayStatus] || displayStatus;
    const cancellableStatuses = ['expanding', 'processing', 'importing', 'enqueued'];
    const showStopButton = Boolean(isAdmin) && session.isLocalImport && cancellableStatuses.includes(session.status);
    const stopButtonHtml = showStopButton
      ? `<button class="btn btn-sm btn-outline-danger btn-size-sm" onclick="stopLocalImport('${session.sessionId}')"><i class="bi bi-stop-circle"></i> ${stopLocalImportLabel}</button>`
      : '';
    let localStatusMessage = '';
    if (session.isLocalImport) {
      if (session.status === 'canceled') {
        localStatusMessage = `<div class="d-inline-flex align-items-center gap-1 small text-muted mt-1"><i class="bi bi-x-circle"></i> ${localImportStopSuccessNotice}</div>`;
      } else if (showStopButton) {
        localStatusMessage = `<div class="d-inline-flex align-items-center gap-1 small text-muted mt-1"><i class="bi bi-info-circle"></i> ${localImportRunningMessage}</div>`;
      } else {
        localStatusMessage = `<div class="d-inline-flex align-items-center gap-1 small text-muted mt-1"><i class="bi bi-info-circle"></i> {{ _("Local Import Session. Import runs automatically.") }}</div>`;
      }
    }
    tr.innerHTML = `
      <td>${session.sessionId || 'N/A'}</td>
      <td><span class="badge bg-${getStatusBadgeClass(displayStatus)}">${statusLabel}</span></td>
      <td>${formatAccountLabel(session)}</td>
      <td><small>${formatCounts(session.counts)}</small></td>
      <td><small>${formatDateTime(session.createdAt)}</small></td>
      <td><small>${formatDateTime(session.lastProgressAt)}</small></td>
      <td class="session-actions">
        <a href="/photo_view?session_id=${session.sessionId}" class="btn btn-sm btn-primary btn-size-sm">{{ _("View Details") }}</a>
        ${(displayStatus === 'ready' && !session.isLocalImport) ? `<button class="btn btn-sm btn-success btn-size-sm" onclick="startImport('${session.sessionId}')">{{ _("Start Import") }}</button>` : ''}
        ${stopButtonHtml}
        ${localStatusMessage}
      </td>
    `;
    return tr;
  }

  function initializeInfiniteScroll() {
    const refreshIcon = document.getElementById('refresh-icon');
    
    const paginationClient = new PaginationClient({
      baseUrl: '/api/picker/sessions',
      pageSize: 50, // Fetch up to 50 sessions per page
      onItemsLoaded: (items, meta) => {
        if (meta.currentPage === 1) {
          sessionsBody.innerHTML = '';
          totalLoaded = 0;
          // Stop the loading animation
          if (refreshIcon) {
            refreshIcon.style.animation = '';
            refreshIcon.classList.remove('fa-spin');
          }
        }
        
        items.forEach(session => {
          const row = createSessionRow(session);
          sessionsBody.appendChild(row);
          totalLoaded++;
        });
        
        if (totalLoaded > 0) {
          sessionCount.textContent = `${totalLoaded} ${sessionsLoadedLabel}`;
        } else {
          sessionCount.textContent = noSessionsLoadedLabel;
        }
      },
      onError: (error) => {
        console.error('Sessions loading error:', error);

        // Redirect to login when authentication fails
        if (error.status === 401 || error.status === 302) {
          window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname);
          return;
        }

        sessionsBody.innerHTML = `<tr><td colspan="7"><div class="alert alert-danger">{{ _("Failed to load sessions.") }}</div></td></tr>`;
        sessionCount.textContent = '{{ _("Error loading sessions") }}';
      }
    });

    // Load the initial page
    paginationClient.loadFirst();
  }

  window.startImport = async function(sessionId) {
    try {
      showInfoToast(startingImportNotice, 3000);

      const resp = await window.apiClient.post(`/api/picker/session/${sessionId}/import`);

      if (!resp.ok) {
        const text = await resp.text().catch(() => '');
        console.error('Import start failed:', resp.status, text);
        showErrorToast('{{ _("Failed to start import.") }}');
        return;
      }

      showSuccessToast('{{ _("Import started.") }}', 5000);
      // Reload the session list
      refreshSessions();
    } catch (err) {
      console.error(err);
      showErrorToast('{{ _("Failed to start import.") }}');
    }
  };

  window.stopLocalImport = async function(sessionId) {
    if (!isAdmin) {
      showErrorToast(localImportStopErrorNotice);
      return;
    }

    if (!window.confirm(localImportCancelConfirmMessage)) {
      return;
    }

    try {
      showInfoToast(localImportStopStartingNotice, 3000);

      const resp = await window.apiClient.post(`/api/sync/local-import/${encodeURIComponent(sessionId)}/stop`);

      if (!resp.ok) {
        const text = await resp.text().catch(() => '');
        console.error('Local import stop failed:', resp.status, text);
        showErrorToast(localImportStopErrorNotice);
        return;
      }

      const payload = await resp.json().catch(() => ({}));
      const message = (payload && payload.message) ? payload.message : localImportStopSuccessNotice;
      showInfoToast(message, 4000);
      refreshSessions();
    } catch (err) {
      console.error(err);
      showErrorToast(localImportStopErrorNotice);
    }
  };

  function refreshSessions() {
    // Spin the refresh icon while reloading
    const refreshIcon = document.getElementById('refresh-icon');
    if (refreshIcon) {
      refreshIcon.classList.add('fa-spin');
    }
    initializeInfiniteScroll();
  }

  // Refresh button handler
  refreshBtn.addEventListener('click', refreshSessions);

  if (accountSelect) {
    accountSelect.addEventListener('change', () => {
      accountSelect.classList.remove('is-invalid');
    });
    accountSelect.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' && createSessionBtn) {
        event.preventDefault();
        createSessionBtn.click();
      }
    });
  }

  if (createSessionBtn) {
    createSessionBtn.addEventListener('click', (event) => {
      event.preventDefault();
      if (!accountSelect) {
        window.location.href = '/auth/picker';
        return;
      }
      const selected = accountSelect.value;
      if (!selected) {
        accountSelect.classList.add('is-invalid');
        if (typeof showInfoToast === 'function') {
          showInfoToast(selectAccountMessage, 4000);
        } else {
          alert(selectAccountMessage);
        }
        return;
      }
      window.location.href = `/auth/picker/${selected}`;
    });
  }

  // Local import button handler
  if (localImportBtn) {
    localImportBtn.addEventListener('click', async (e) => {
      e.preventDefault();

      const importDisplay = localImportBtn.dataset.importDisplay || localImportBtn.dataset.importAbsolute || '';
      const importReal = localImportBtn.dataset.importRealpath || '';
      const importExists = localImportBtn.dataset.importExists === '1';
      const destinationDisplay = localImportBtn.dataset.destinationDisplay || localImportBtn.dataset.destinationAbsolute || '';
      const destinationReal = localImportBtn.dataset.destinationRealpath || '';
      const destinationExists = localImportBtn.dataset.destinationExists === '1';
      const duplicateMode = getSelectedDuplicateMode();
      const duplicateModeInfo = describeDuplicateMode(duplicateMode);

      const confirmLines = [localImportPromptHeader];
      if (importDisplay) {
        let sourceLine = `${localImportSourceLabel}: ${importDisplay}`;
        if (importReal && importReal !== importDisplay) {
          sourceLine += ` (${localImportResolvedLabel}: ${importReal})`;
        }
        if (!importExists) {
          sourceLine += ` [${localImportMissingLabel}]`;
        }
        confirmLines.push(sourceLine);
      }
      if (destinationDisplay) {
        let destinationLine = `${localImportDestinationLabel}: ${destinationDisplay}`;
        if (destinationReal && destinationReal !== destinationDisplay) {
          destinationLine += ` (${localImportResolvedLabel}: ${destinationReal})`;
        }
        if (!destinationExists) {
          destinationLine += ` [${localImportMissingLabel}]`;
        }
        confirmLines.push(destinationLine);
      } else {
        confirmLines.push(localImportDestinationUnset);
      }
      confirmLines.push(`${duplicateModeSummaryLabel}: ${duplicateModeInfo.label}`);
      if (duplicateModeInfo.description) {
        confirmLines.push(duplicateModeInfo.description);
      }
      confirmLines.push(localImportRemovalNotice);

      if (!confirm(confirmLines.join('\n'))) {
        return;
      }

      try {
        // Notify that the import is starting
        showInfoToast(localImportStartingNotice, 3000);

        const resp = await window.apiClient.post('/api/sync/local-import', {
          duplicateRegeneration: duplicateMode,
        });

        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          console.error('Local import failed:', resp.status, text);
          showErrorToast(localImportErrorNotice);
          return;
        }

        const payload = await resp.json().catch(() => ({}));
        showSuccessToast(localImportSuccessNotice, 8000);

        const sessionId = payload && payload.session_id;
        if (sessionId) {
          setTimeout(() => {
            window.location.href = `/photo_view?session_id=${encodeURIComponent(sessionId)}`;
          }, 1500);
          return;
        }

        // Automatically refresh the session list when no session ID is returned
        setTimeout(() => {
          refreshSessions();
        }, 2000);
      } catch (err) {
        console.error(err);
        showErrorToast(localImportErrorNotice);
      }
    });
  }

  // Check authentication status and redirect when necessary
  function checkAuthAndRedirect() {
    // A simple API call is enough because the API client handles refresh tokens
    window.apiClient.get('/api/picker/sessions', {
      method: 'HEAD'
    }).then(response => {
      if (response.status === 401 || response.status === 302) {
        // Redirect to login when authentication is required
        window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname);
      }
    }).catch(error => {
      console.warn('Auth check failed:', error);
      // Ignore network errors
    });
  }

  // Initialise the page
  checkAuthAndRedirect();
  initializeInfiniteScroll();

  // Periodically refresh (every five seconds)
  setInterval(refreshSessions, 5000);
});
</script>
{% endblock %}
