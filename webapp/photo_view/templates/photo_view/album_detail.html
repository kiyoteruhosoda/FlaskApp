{% extends 'base.html' %}
{% block title %}{{ _('Album Detail') }}{% endblock %}

{% block extra_head %}
<style>
  .album-detail-page {
    max-width: 1200px;
  }

  .album-detail-header h1 {
    font-size: clamp(1.8rem, 2.4vw, 2.4rem);
    font-weight: 700;
    color: #0f172a;
  }

  .album-detail-header .text-muted {
    font-size: 0.95rem;
  }

  .album-detail-description {
    font-size: 1.05rem;
    color: #475569;
  }

  .album-badges .badge {
    font-size: 0.9rem;
    padding: 0.45rem 0.9rem;
    border-radius: 999px;
  }

  .album-media-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 18px;
  }

  .album-media-grid.reorder-active .album-media-tile {
    cursor: grab;
  }

  .album-media-tile {
    position: relative;
    border: none;
    border-radius: 16px;
    overflow: hidden;
    padding: 0;
    background: #0f172a;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .album-media-tile:hover {
    transform: translateY(-4px);
    box-shadow: 0 16px 32px rgba(15, 23, 42, 0.28);
  }

  .album-media-tile img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    aspect-ratio: 4 / 3;
  }

  .album-media-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 12px;
    background: linear-gradient(180deg, rgba(15, 23, 42, 0.05) 0%, rgba(15, 23, 42, 0.6) 80%);
    color: #f8fafc;
  }

  .album-media-overlay .badge {
    align-self: flex-start;
    background: rgba(15, 23, 42, 0.65);
    border-radius: 999px;
    padding: 0.35rem 0.8rem;
    font-size: 0.8rem;
    letter-spacing: 0.02em;
  }

  .album-media-overlay .media-meta {
    font-size: 0.85rem;
    color: rgba(241, 245, 249, 0.9);
  }

  .album-media-empty {
    font-size: 1.1rem;
  }

  .album-media-tile.reorder-dragging {
    opacity: 0.65;
  }

  .album-media-tile.reorder-drop-before::after,
  .album-media-tile.reorder-drop-after::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    height: 4px;
    background: rgba(37, 99, 235, 0.85);
    box-shadow: 0 0 12px rgba(37, 99, 235, 0.45);
  }

  .album-media-tile.reorder-drop-before::after {
    top: 0;
  }

  .album-media-tile.reorder-drop-after::after {
    bottom: 0;
  }

  .album-media-drag-handle {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(15, 23, 42, 0.7);
    border-radius: 999px;
    padding: 0.25rem 0.45rem;
    color: #f8fafc;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.15rem;
    pointer-events: none;
  }

  .album-reorder-hint {
    border-radius: 12px;
    padding: 0.85rem 1rem;
  }

  @media (max-width: 768px) {
    .album-media-grid {
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    }
  }
</style>
{% endblock %}

{% block content %}
<div class="album-detail-page container-xl py-4" data-album-id="{{ album_id }}">
  <div class="album-detail-header d-flex align-items-start justify-content-between flex-wrap gap-3 mb-4">
    <div class="d-flex align-items-center gap-2">
      <a class="btn btn-outline-secondary" href="{{ url_for('photo_view.albums') }}">
        <i class="bi bi-arrow-left"></i> {{ _('Back to albums') }}
      </a>
    </div>
    <div class="flex-grow-1">
      <h1 id="album-title" class="mb-2">{{ _('Album Detail') }}</h1>
      <div id="album-meta" class="text-muted"></div>
    </div>
    <div class="d-flex flex-wrap gap-2 align-items-center">
      <button type="button" class="btn btn-primary" id="start-slideshow-btn" disabled>
        <i class="bi bi-play-fill me-1"></i>{{ _('Start Slideshow') }}
      </button>
      <a class="btn btn-outline-primary" href="{{ url_for('photo_view.media_list') }}">
        <i class="bi bi-images me-1"></i>{{ _('View Media Library') }}
      </a>
      <button type="button" class="btn btn-outline-secondary" id="album-reorder-toggle">
        <i class="bi bi-arrow-down-up me-1"></i>{{ _('Reorder media') }}
      </button>
      <button type="button" class="btn btn-success d-none" id="album-reorder-save">
        <i class="bi bi-check-lg me-1"></i>{{ _('Save order') }}
      </button>
      <button type="button" class="btn btn-outline-secondary d-none" id="album-reorder-cancel">
        <i class="bi bi-x-lg me-1"></i>{{ _('Cancel') }}
      </button>
    </div>
  </div>

  <p id="album-description" class="album-detail-description d-none"></p>

  <div id="album-loading" class="text-center py-5">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">{{ _('Loading...') }}</span>
    </div>
  </div>

  <div id="album-error" class="alert alert-danger d-none" role="alert">
    <i class="bi bi-exclamation-triangle-fill me-2"></i>{{ _('Failed to load album information.') }}
  </div>

  <div id="album-detail-content" class="d-none">
    <div class="album-badges d-flex flex-wrap gap-2 mb-3">
      <span class="badge bg-primary" id="album-visibility"></span>
      <span class="badge bg-secondary" id="album-media-count"></span>
      <span class="badge bg-light text-muted" id="album-created-at"></span>
      <span class="badge bg-light text-muted d-none" id="album-updated-at"></span>
    </div>

    <div id="album-reorder-hint" class="album-reorder-hint alert alert-info d-none" role="status" aria-live="polite"></div>

    <div id="album-media-empty" class="album-media-empty alert alert-info d-none" role="status">
      <i class="bi bi-info-circle me-2"></i>{{ _('This album has no media yet.') }}
    </div>

    <div id="album-media-grid" class="album-media-grid"></div>
  </div>
</div>

<div id="album-slideshow-overlay" class="album-slideshow-overlay d-none" aria-hidden="true">
  <div class="album-slideshow-dialog">
    <button type="button" class="album-slideshow-close" id="album-slideshow-close" aria-label="{{ _('Close') }}">
      <i class="bi bi-x-lg"></i>
    </button>
    <div id="album-slideshow-loading" class="album-slideshow-loading d-none">
      <div class="spinner-border text-light" role="status"></div>
      <span>{{ _('Loading slideshow...') }}</span>
    </div>
    <div id="album-slideshow-stage" class="album-slideshow-stage d-none">
      <button type="button" class="album-slideshow-nav prev" id="album-slideshow-prev" aria-label="{{ _('Previous') }}">
        <i class="bi bi-chevron-left"></i>
      </button>
      <img id="album-slideshow-image" src="" alt="" loading="lazy">
      <button type="button" class="album-slideshow-nav next" id="album-slideshow-next" aria-label="{{ _('Next') }}">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
    <div id="album-slideshow-empty" class="album-slideshow-empty d-none">
      {{ _('This album has no media yet.') }}
    </div>
    <div class="album-slideshow-footer">
      <div class="album-slideshow-info">
        <span class="album-title" id="album-slideshow-title"></span>
        <span class="album-meta" id="album-slideshow-meta"></span>
      </div>
      <div class="album-slideshow-controls">
        <div class="album-slideshow-counter" id="album-slideshow-counter"></div>
        <button type="button" class="btn btn-outline-light" id="album-slideshow-toggle">
          <i class="bi bi-play-fill me-1"></i><span data-label>{{ _('Play') }}</span>
        </button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script src="{{ url_for('static', filename='js/album-slideshow.js') }}"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const albumId = Number('{{ album_id }}');
  const apiClient = new APIClient();
  const state = {
    album: null,
    media: [],
  };

  const slideshowIntentStorageKey = 'photoView.slideshowIntent';
  const autoplayQueryKeys = ['slideshow', 'autoplay'];

  function parseAutoplayFlag(value) {
    if (value === null || value === undefined) {
      return false;
    }
    const normalized = value.toString().trim().toLowerCase();
    if (!normalized) {
      return false;
    }
    return !['0', 'false', 'no', 'off'].includes(normalized);
  }

  function consumeSlideshowIntent() {
    let shouldAutoplay = false;
    const params = new URLSearchParams(window.location.search);
    const queryValues = autoplayQueryKeys.map((key) => params.get(key));
    if (queryValues.some((value) => parseAutoplayFlag(value))) {
      shouldAutoplay = true;
    }

    let storedIntentRaw = null;
    try {
      storedIntentRaw = window.sessionStorage?.getItem(slideshowIntentStorageKey) || null;
    } catch (error) {
      console.warn('Failed to access slideshow intent storage', error);
    }

    if (storedIntentRaw) {
      try {
        const parsedIntent = JSON.parse(storedIntentRaw);
        if (Number(parsedIntent?.albumId) === albumId) {
          const expiresAt = Number(parsedIntent?.expiresAt);
          if (!Number.isFinite(expiresAt) || expiresAt >= Date.now()) {
            shouldAutoplay = true;
          }
        }
      } catch (error) {
        console.warn('Failed to parse slideshow intent payload', error);
      }
    }

    try {
      window.sessionStorage?.removeItem(slideshowIntentStorageKey);
    } catch (error) {
      console.warn('Failed to clear slideshow intent storage', error);
    }

    if (queryValues.some((value) => value !== null)) {
      autoplayQueryKeys.forEach((key) => params.delete(key));
      const newQuery = params.toString();
      const newUrl = `${window.location.pathname}${newQuery ? `?${newQuery}` : ''}${window.location.hash}`;
      try {
        window.history.replaceState({}, document.title, newUrl);
      } catch (error) {
        console.warn('Failed to update URL after consuming slideshow intent', error);
      }
    }

    return shouldAutoplay;
  }

  let autoplayOnLoad = consumeSlideshowIntent();

  const reorderState = {
    active: false,
    originalMedia: [],
    originalIds: [],
    dirty: false,
    saving: false,
    dragSourceIndex: null,
  };

  const strings = {
    untitledAlbum: "{{ _('Untitled Album')|escapejs }}",
    mediaCountSingular: "{{ ngettext('%(count)s photo', '%(count)s photos', 1, count='%(count)s')|escapejs }}",
    mediaCountPlural: "{{ ngettext('%(count)s photo', '%(count)s photos', 2, count='%(count)s')|escapejs }}",
    createdLabel: "{{ _('Created')|escapejs }}",
    updatedLabel: "{{ _('Updated')|escapejs }}",
    shotAtLabel: "{{ _('Shot at')|escapejs }}",
    positionLabel: "{{ _('%(current)s / %(total)s', current='%(current)s', total='%(total)s')|escapejs }}",
    loadingError: "{{ _('Failed to load album information.')|escapejs }}",
    slideshowLoading: "{{ _('Loading slideshow...')|escapejs }}",
    noMedia: "{{ _('This album has no media yet.')|escapejs }}",
    reorderHint: "{{ _('Drag and drop media tiles to change their order.')|escapejs }}",
    reorderDirtyHint: "{{ _('Don\'t forget to save your changes.')|escapejs }}",
    reorderSaving: "{{ _('Saving order...')|escapejs }}",
    reorderSaved: "{{ _('Media order updated.')|escapejs }}",
    reorderSaveError: "{{ _('Failed to save media order.')|escapejs }}",
    visibilityLabels: {
      public: "{{ _('Public')|escapejs }}",
      private: "{{ _('Private')|escapejs }}",
      unlisted: "{{ _('Unlisted')|escapejs }}",
    },
  };

  const THUMBNAIL_SIZE_PRIORITY = [2048, 1024, 512];

  function sortAlbumMediaItems(items) {
    if (!Array.isArray(items)) {
      return [];
    }
    const normalizeIndex = (value, fallback = Number.MAX_SAFE_INTEGER) => {
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : fallback;
    };
    return items
      .slice()
      .sort((a, b) => {
        const sortA = normalizeIndex(a?.sortIndex);
        const sortB = normalizeIndex(b?.sortIndex);
        if (sortA !== sortB) {
          return sortA - sortB;
        }
        const idA = normalizeIndex(a?.id);
        const idB = normalizeIndex(b?.id);
        return idA - idB;
      });
  }

  function normalizeThumbnailSize(value) {
    if (typeof value === 'number' && Number.isFinite(value)) {
      return value;
    }
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (trimmed) {
        const parsed = Number.parseInt(trimmed, 10);
        if (Number.isFinite(parsed)) {
          return parsed;
        }
      }
    }
    return null;
  }

  function collectThumbnailAvailability(item) {
    const available = new Set();
    const urlBySize = new Map();

    const register = (size, url) => {
      if (!Number.isFinite(size)) {
        return;
      }
      available.add(size);
      if (typeof url === 'string' && url) {
        urlBySize.set(size, url);
      }
    };

    const variantSources = [
      item?.thumbnailUrls,
      item?.thumbnails,
      item?.thumbnail_variants,
      item?.thumbnailVariants,
    ];

    variantSources.forEach((source) => {
      if (!source) {
        return;
      }
      if (Array.isArray(source)) {
        source.forEach((entry) => {
          if (entry && typeof entry === 'object' && !Array.isArray(entry)) {
            const size = normalizeThumbnailSize(entry.size ?? entry.dimension ?? entry.width ?? entry.height);
            const url = entry.url ?? entry.href ?? entry.path ?? null;
            if (size !== null) {
              register(size, typeof url === 'string' ? url : null);
            }
          } else {
            const size = normalizeThumbnailSize(entry);
            if (size !== null) {
              register(size);
            }
          }
        });
      } else if (typeof source === 'object') {
        Object.entries(source).forEach(([key, value]) => {
          const keySize = normalizeThumbnailSize(key);
          if (typeof value === 'string') {
            if (keySize !== null) {
              register(keySize, value);
            }
            return;
          }
          if (value && typeof value === 'object' && !Array.isArray(value)) {
            const nestedSize = normalizeThumbnailSize(
              value.size ?? value.dimension ?? value.width ?? value.height ?? keySize,
            );
            const url = value.url ?? value.href ?? value.path ?? null;
            if (nestedSize !== null) {
              register(nestedSize, typeof url === 'string' ? url : null);
            } else if (keySize !== null) {
              register(keySize, typeof url === 'string' ? url : null);
            }
          } else if (value && keySize !== null) {
            register(keySize);
          }
        });
      }
    });

    const availabilitySources = [
      item?.availableThumbnailSizes,
      item?.thumbnailSizes,
      item?.availableThumbnails,
    ];

    availabilitySources.forEach((source) => {
      if (!source) {
        return;
      }
      if (Array.isArray(source)) {
        source.forEach((entry) => {
          const size = normalizeThumbnailSize(entry);
          if (size !== null) {
            available.add(size);
          }
        });
      } else if (typeof source === 'object') {
        Object.entries(source).forEach(([key, value]) => {
          if (!value) {
            return;
          }
          const size = normalizeThumbnailSize(key);
          if (size !== null) {
            available.add(size);
          }
        });
      }
    });

    return { available, urlBySize };
  }

  function resolveSlideshowImageUrl(item) {
    if (!item) {
      return '';
    }

    const { available, urlBySize } = collectThumbnailAvailability(item);
    const buildUrl = (size) => (item.id ? `/api/media/${item.id}/thumbnail?size=${size}` : '');

    for (const size of THUMBNAIL_SIZE_PRIORITY) {
      if (urlBySize.has(size)) {
        return urlBySize.get(size);
      }
      if (available.has(size)) {
        const resolved = buildUrl(size);
        if (resolved) {
          return resolved;
        }
      }
    }

    if (typeof item.thumbnailUrl === 'string' && item.thumbnailUrl) {
      return item.thumbnailUrl;
    }

    return buildUrl(512);
  }

  const elements = {
    loading: document.getElementById('album-loading'),
    error: document.getElementById('album-error'),
    content: document.getElementById('album-detail-content'),
    title: document.getElementById('album-title'),
    meta: document.getElementById('album-meta'),
    description: document.getElementById('album-description'),
    visibility: document.getElementById('album-visibility'),
    mediaCount: document.getElementById('album-media-count'),
    createdAt: document.getElementById('album-created-at'),
    updatedAt: document.getElementById('album-updated-at'),
    mediaGrid: document.getElementById('album-media-grid'),
    mediaEmpty: document.getElementById('album-media-empty'),
    slideshowButton: document.getElementById('start-slideshow-btn'),
  };

  const reorderElements = {
    toggle: document.getElementById('album-reorder-toggle'),
    save: document.getElementById('album-reorder-save'),
    cancel: document.getElementById('album-reorder-cancel'),
    hint: document.getElementById('album-reorder-hint'),
  };

  const slideshow = new AlbumSlideshow({
    overlayElement: document.getElementById('album-slideshow-overlay'),
    stageElement: document.getElementById('album-slideshow-stage'),
    imageElement: document.getElementById('album-slideshow-image'),
    titleElement: document.getElementById('album-slideshow-title'),
    metaElement: document.getElementById('album-slideshow-meta'),
    counterElement: document.getElementById('album-slideshow-counter'),
    emptyStateElement: document.getElementById('album-slideshow-empty'),
    loadingElement: document.getElementById('album-slideshow-loading'),
    playPauseButton: document.getElementById('album-slideshow-toggle'),
    prevButton: document.getElementById('album-slideshow-prev'),
    nextButton: document.getElementById('album-slideshow-next'),
    closeButton: document.getElementById('album-slideshow-close'),
    labels: {
      play: "{{ _('Play')|escapejs }}",
      pause: "{{ _('Pause')|escapejs }}",
      next: "{{ _('Next')|escapejs }}",
      previous: "{{ _('Previous')|escapejs }}",
      close: "{{ _('Close')|escapejs }}",
      counter: "{{ _('%(current)s / %(total)s', current='%(current)s', total='%(total)s')|escapejs }}",
      noMedia: strings.noMedia,
      shotAt: strings.shotAtLabel,
      albumTitleFallback: "{{ _('Album')|escapejs }}",
    },
    imageUrlResolver: resolveSlideshowImageUrl,
    metadataFormatter: (item, context) => {
      const parts = [];
      if (item?.shotAt) {
        const formatted = formatDateTime(item.shotAt);
        if (formatted) {
          parts.push(`${strings.shotAtLabel} ${formatted}`);
        }
      }
      parts.push(
        strings.positionLabel
          .replace('%(current)s', (context.index + 1).toString())
          .replace('%(total)s', context.total.toString()),
      );
      return parts.join(' · ');
    },
  });

  function showReorderHint(message, level = 'info') {
    if (!reorderElements.hint) {
      return;
    }
    const normalized = ['success', 'warning', 'danger', 'info'].includes(level) ? level : 'info';
    reorderElements.hint.textContent = message;
    reorderElements.hint.classList.remove('d-none', 'alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    reorderElements.hint.classList.add(`alert-${normalized}`);
  }

  function hideReorderHint() {
    if (!reorderElements.hint) {
      return;
    }
    reorderElements.hint.classList.add('d-none');
    reorderElements.hint.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    reorderElements.hint.textContent = '';
  }

  function updateSlideshowButtonState() {
    if (!elements.slideshowButton) {
      return;
    }
    elements.slideshowButton.disabled = reorderState.active || state.media.length === 0;
  }

  function updateReorderToggleAvailability() {
    if (!reorderElements.toggle || reorderState.active) {
      return;
    }
    reorderElements.toggle.disabled = state.media.length < 2;
  }

  function updateReorderSaveState() {
    if (reorderElements.save) {
      reorderElements.save.disabled = !reorderState.dirty || reorderState.saving;
    }
    if (reorderElements.cancel) {
      reorderElements.cancel.disabled = reorderState.saving;
    }
  }

  function clearAllDropIndicators() {
    if (!elements.mediaGrid) {
      return;
    }
    elements.mediaGrid.querySelectorAll('.album-media-tile').forEach((tile) => {
      tile.classList.remove('reorder-drop-before', 'reorder-drop-after', 'reorder-dragging');
      if (reorderState.active) {
        tile.setAttribute('aria-grabbed', 'false');
      } else {
        tile.removeAttribute('aria-grabbed');
      }
    });
  }

  function evaluateReorderDirty() {
    if (!reorderState.active) {
      reorderState.dirty = false;
      return false;
    }
    const currentIds = state.media
      .map((item) => Number(item?.id))
      .filter((id) => Number.isFinite(id));
    const reference = reorderState.originalIds;
    const isDirty =
      currentIds.length !== reference.length ||
      currentIds.some((id, index) => id !== reference[index]);
    reorderState.dirty = isDirty;
    return isDirty;
  }

  function applyReorderMode() {
    if (elements.mediaGrid) {
      elements.mediaGrid.classList.toggle('reorder-active', reorderState.active);
    }
    if (reorderElements.toggle) {
      reorderElements.toggle.classList.toggle('d-none', reorderState.active);
      if (!reorderState.active) {
        reorderElements.toggle.disabled = state.media.length < 2;
      }
    }
    if (reorderElements.save) {
      reorderElements.save.classList.toggle('d-none', !reorderState.active);
    }
    if (reorderElements.cancel) {
      reorderElements.cancel.classList.toggle('d-none', !reorderState.active);
    }
    updateSlideshowButtonState();
    updateReorderSaveState();
    if (!reorderState.active) {
      clearAllDropIndicators();
    }
  }

  function resetReorderState() {
    reorderState.active = false;
    reorderState.originalMedia = [];
    reorderState.originalIds = [];
    reorderState.dirty = false;
    reorderState.saving = false;
    reorderState.dragSourceIndex = null;
    hideReorderHint();
    applyReorderMode();
  }

  function enterReorderMode() {
    if (reorderState.active || state.media.length === 0) {
      if (state.media.length === 0) {
        showInfoToast(strings.noMedia);
      }
      return;
    }
    reorderState.active = true;
    reorderState.originalMedia = state.media.slice();
    reorderState.originalIds = reorderState.originalMedia
      .map((item) => Number(item?.id))
      .filter((id) => Number.isFinite(id));
    reorderState.dirty = false;
    reorderState.saving = false;
    reorderState.dragSourceIndex = null;
    applyReorderMode();
    renderMediaGrid();
    showReorderHint(strings.reorderHint, 'info');
  }

  function cancelReorderMode() {
    if (!reorderState.active || reorderState.saving) {
      return;
    }
    state.media = reorderState.originalMedia.slice();
    resetReorderState();
    renderAlbumDetail();
    slideshow.load(state.media, { albumTitle: state.album?.title || strings.untitledAlbum });
  }

  async function saveMediaOrder() {
    if (!reorderState.active || reorderState.saving) {
      return;
    }
    const mediaIds = state.media
      .map((item) => Number(item?.id))
      .filter((id) => Number.isFinite(id));
    if (mediaIds.length !== state.media.length) {
      showErrorToast(strings.reorderSaveError);
      return;
    }

    reorderState.saving = true;
    updateReorderSaveState();
    showReorderHint(strings.reorderSaving, 'warning');

    try {
      const response = await apiClient.put(`/api/albums/${albumId}/media/order`, { mediaIds });
      const data = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message = data?.message || `HTTP ${response.status}`;
        throw new Error(message);
      }
      if (data?.album) {
        state.album = data.album;
        state.media = sortAlbumMediaItems(Array.isArray(data.album.media) ? data.album.media : state.media);
      }
      showSuccessToast(strings.reorderSaved);
      resetReorderState();
      renderAlbumDetail();
      slideshow.load(state.media, { albumTitle: state.album?.title || strings.untitledAlbum });
    } catch (error) {
      console.error('Failed to save album media order', error);
      showErrorToast(strings.reorderSaveError);
      showReorderHint(strings.reorderHint, 'info');
      evaluateReorderDirty();
      updateReorderSaveState();
    } finally {
      reorderState.saving = false;
      updateReorderSaveState();
    }
  }

  function performMediaReorder(fromIndex, toIndex) {
    if (!reorderState.active) {
      return;
    }
    if (!Number.isInteger(fromIndex) || !Number.isInteger(toIndex)) {
      return;
    }
    const count = state.media.length;
    if (count <= 1) {
      return;
    }
    const clampedFrom = Math.max(0, Math.min(fromIndex, count - 1));
    let clampedTo = Math.max(0, Math.min(toIndex, count));
    if (clampedFrom === clampedTo || clampedFrom + 1 === clampedTo) {
      clearAllDropIndicators();
      return;
    }
    const reordered = state.media.slice();
    const [moved] = reordered.splice(clampedFrom, 1);
    if (!moved) {
      return;
    }
    if (clampedFrom < clampedTo) {
      clampedTo -= 1;
    }
    reordered.splice(clampedTo, 0, moved);
    state.media = reordered;
    reorderState.dragSourceIndex = null;
    clearAllDropIndicators();
    const dirty = evaluateReorderDirty();
    renderMediaGrid();
    showReorderHint(dirty ? strings.reorderDirtyHint : strings.reorderHint, 'info');
  }

  function onTileDragStart(event) {
    if (!reorderState.active) {
      event.preventDefault();
      return;
    }
    const tile = event.currentTarget;
    const index = Number(tile.dataset.index);
    if (!Number.isInteger(index)) {
      event.preventDefault();
      return;
    }
    reorderState.dragSourceIndex = index;
    tile.classList.add('reorder-dragging');
    tile.setAttribute('aria-grabbed', 'true');
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', index.toString());
  }

  function onTileDragOver(event) {
    if (!reorderState.active) {
      return;
    }
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    const tile = event.currentTarget;
    const rect = tile.getBoundingClientRect();
    const offsetX = event.clientX - rect.left;
    const offsetY = event.clientY - rect.top;
    const dropAfter = rect.width >= rect.height ? offsetX > rect.width / 2 : offsetY > rect.height / 2;
    tile.classList.toggle('reorder-drop-before', !dropAfter);
    tile.classList.toggle('reorder-drop-after', dropAfter);
  }

  function onTileDragLeave(event) {
    if (!reorderState.active) {
      return;
    }
    const tile = event.currentTarget;
    tile.classList.remove('reorder-drop-before', 'reorder-drop-after');
  }

  function onTileDrop(event) {
    if (!reorderState.active) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    const tile = event.currentTarget;
    const targetIndex = Number(tile.dataset.index);
    const sourceIndex = reorderState.dragSourceIndex;
    if (!Number.isInteger(targetIndex) || !Number.isInteger(sourceIndex)) {
      clearAllDropIndicators();
      return;
    }
    const rect = tile.getBoundingClientRect();
    const offsetX = event.clientX - rect.left;
    const offsetY = event.clientY - rect.top;
    const dropAfter = rect.width >= rect.height ? offsetX > rect.width / 2 : offsetY > rect.height / 2;
    const insertIndex = dropAfter ? targetIndex + 1 : targetIndex;
    performMediaReorder(sourceIndex, insertIndex);
  }

  function onTileDragEnd(event) {
    if (!reorderState.active) {
      return;
    }
    const tile = event.currentTarget;
    tile.classList.remove('reorder-dragging');
    tile.classList.remove('reorder-drop-before', 'reorder-drop-after');
    tile.setAttribute('aria-grabbed', 'false');
    reorderState.dragSourceIndex = null;
    clearAllDropIndicators();
  }

  async function loadAlbumDetail() {
    elements.loading.classList.remove('d-none');
    elements.error.classList.add('d-none');
    elements.content.classList.add('d-none');
    try {
      const response = await apiClient.get(`/api/albums/${albumId}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data = await response.json();
      if (!data?.album) {
        throw new Error('Missing album payload');
      }
      state.album = data.album;
      state.media = sortAlbumMediaItems(Array.isArray(data.album.media) ? data.album.media : []);
      resetReorderState();
      renderAlbumDetail();
      elements.content.classList.remove('d-none');
      updateSlideshowButtonState();
      slideshow.load(state.media, { albumTitle: state.album.title || strings.untitledAlbum });
      if (autoplayOnLoad) {
        if (!state.media.length) {
          showInfoToast(strings.noMedia);
          slideshow.open(0, { autoplay: false });
        } else {
          slideshow.open(0);
        }
        autoplayOnLoad = false;
      }
    } catch (error) {
      console.error('Failed to load album detail', error);
      elements.error.classList.remove('d-none');
      elements.error.textContent = strings.loadingError;
      elements.content.classList.add('d-none');
    } finally {
      elements.loading.classList.add('d-none');
    }
  }

  function renderAlbumDetail() {
    const album = state.album;
    const title = album.title?.trim() || strings.untitledAlbum;
    elements.title.textContent = title;

    const visibilityLabel = strings.visibilityLabels[album.visibility] || album.visibility || '';
    elements.visibility.textContent = visibilityLabel;

    const mediaCountText = formatMediaCount(album.mediaCount ?? state.media.length);
    elements.mediaCount.textContent = mediaCountText;

    const createdText = formatDateTime(album.createdAt);
    elements.createdAt.textContent = createdText ? `${strings.createdLabel}: ${createdText}` : '';

    const updatedText = formatDateTime(album.lastModified);
    if (updatedText) {
      elements.updatedAt.textContent = `${strings.updatedLabel}: ${updatedText}`;
      elements.updatedAt.classList.remove('d-none');
    } else {
      elements.updatedAt.classList.add('d-none');
    }

    if (album.description) {
      elements.description.textContent = album.description;
      elements.description.classList.remove('d-none');
    } else {
      elements.description.textContent = '';
      elements.description.classList.add('d-none');
    }

    const metaParts = [];
    if (visibilityLabel) {
      metaParts.push(visibilityLabel);
    }
    if (mediaCountText) {
      metaParts.push(mediaCountText);
    }
    if (createdText) {
      metaParts.push(`${strings.createdLabel}: ${createdText}`);
    }
    if (updatedText) {
      metaParts.push(`${strings.updatedLabel}: ${updatedText}`);
    }
    elements.meta.textContent = metaParts.join(' · ');

    renderMediaGrid();
  }

  function renderMediaGrid() {
    elements.mediaGrid.innerHTML = '';
    elements.mediaGrid.classList.toggle('reorder-active', reorderState.active);

    if (!state.media.length) {
      elements.mediaEmpty.classList.remove('d-none');
      hideReorderHint();
      updateSlideshowButtonState();
      updateReorderToggleAvailability();
      updateReorderSaveState();
      return;
    }

    elements.mediaEmpty.classList.add('d-none');

    state.media.forEach((item, index) => {
      const tile = document.createElement('button');
      tile.type = 'button';
      tile.className = 'album-media-tile';
      tile.dataset.index = index.toString();
      const mediaId = Number(item?.id);
      if (Number.isFinite(mediaId)) {
        tile.dataset.mediaId = mediaId.toString();
      }

      const thumbnailSrc = item?.thumbnailUrl || (Number.isFinite(mediaId) ? `/api/media/${mediaId}/thumbnail?size=512` : '');
      const safeTitle = escapeHtml(item?.filename || titleForMedia(item));
      const shotMeta = item?.shotAt ? `<div class="media-meta">${escapeHtml(formatShotAt(item.shotAt))}</div>` : '';
      const dragHandle = reorderState.active
        ? '<div class="album-media-drag-handle" aria-hidden="true"><i class="bi bi-grip-vertical"></i></div>'
        : '';

      tile.innerHTML = `
        <img src="${thumbnailSrc}" alt="${safeTitle}" loading="lazy">
        <div class="album-media-overlay">
          <span class="badge">${index + 1}</span>
          ${shotMeta}
        </div>
        ${dragHandle}
      `;

      if (reorderState.active) {
        tile.setAttribute('draggable', 'true');
        tile.setAttribute('aria-grabbed', 'false');
        tile.addEventListener('dragstart', onTileDragStart);
        tile.addEventListener('dragover', onTileDragOver);
        tile.addEventListener('dragleave', onTileDragLeave);
        tile.addEventListener('drop', onTileDrop);
        tile.addEventListener('dragend', onTileDragEnd);
      } else {
        tile.addEventListener('click', () => {
          slideshow.open(index, { autoplay: false });
        });
      }

      elements.mediaGrid.appendChild(tile);
    });

    updateSlideshowButtonState();
    updateReorderToggleAvailability();
    updateReorderSaveState();
  }

  function formatMediaCount(count) {
    const value = Number(count) || 0;
    const template = value === 1 ? strings.mediaCountSingular : strings.mediaCountPlural;
    return template.replace('%(count)s', value.toString());
  }

  function formatShotAt(isoString) {
    const formatted = formatDateTime(isoString);
    return formatted || '';
  }

  function formatDateTime(isoString) {
    if (!isoString) {
      return '';
    }
    const helper = window.appTime;
    if (helper && typeof helper.formatDateTime === 'function') {
      try {
        const formatted = helper.formatDateTime(isoString, { dateStyle: 'medium', timeStyle: 'short' });
        if (formatted) {
          return formatted;
        }
      } catch (error) {
        console.warn('formatDateTime failed', error);
      }
    }
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) {
      return '';
    }
    return date.toLocaleString();
  }

  function titleForMedia(item) {
    if (!item) {
      return strings.untitledAlbum;
    }
    return item.filename || item.id?.toString() || strings.untitledAlbum;
  }

  function escapeHtml(value) {
    if (value === null || value === undefined) {
      return '';
    }
    return value
      .toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  elements.slideshowButton.addEventListener('click', () => {
    if (!state.media.length) {
      showInfoToast(strings.noMedia);
      return;
    }
    slideshow.open(0);
  });

  if (reorderElements.toggle) {
    reorderElements.toggle.addEventListener('click', () => {
      enterReorderMode();
    });
  }

  if (reorderElements.cancel) {
    reorderElements.cancel.addEventListener('click', () => {
      cancelReorderMode();
    });
  }

  if (reorderElements.save) {
    reorderElements.save.addEventListener('click', () => {
      saveMediaOrder();
    });
  }

  if (elements.mediaGrid) {
    elements.mediaGrid.addEventListener('dragover', (event) => {
      if (!reorderState.active) {
        return;
      }
      event.preventDefault();
    });

    elements.mediaGrid.addEventListener('drop', (event) => {
      if (!reorderState.active) {
        return;
      }
      event.preventDefault();
      const targetTile = event.target instanceof Element ? event.target.closest('.album-media-tile') : null;
      if (targetTile) {
        return;
      }
      const sourceIndex = reorderState.dragSourceIndex;
      if (!Number.isInteger(sourceIndex)) {
        clearAllDropIndicators();
        reorderState.dragSourceIndex = null;
        return;
      }
      performMediaReorder(sourceIndex, state.media.length);
    });
  }

  loadAlbumDetail();
});
</script>
{% endblock %}
