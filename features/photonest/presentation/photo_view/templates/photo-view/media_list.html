{% extends 'base.html' %}
{% block title %}Media List{% endblock %}

{% block extra_head %}
<script src="{{ url_for('static', filename='js/filter-state.js') }}"></script>
<script src="{{ url_for('static', filename='js/pagination.js') }}"></script>
<style>
  .controls-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: flex-start;
    align-items: center;
    margin-bottom: 20px;
    padding: 12px 16px;
    background: #f8f9fa;
    border-radius: 8px;
  }
  
  .view-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    justify-content: flex-end;
    margin-left: auto;
  }

  .tag-filter {
    flex: 0 1 320px;
    max-width: 360px;
    width: 100%;
    position: relative;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .tag-filter label {
    font-size: 0.85rem;
    color: #6c757d;
    margin-bottom: 0;
    display: flex;
    align-items: center;
    white-space: nowrap;
  }

  .tag-filter-box {
    position: relative;
    background: white;
    border: 1px solid #ced4da;
    border-radius: 6px;
    padding: 6px;
    min-height: 38px;
    flex: 1;
  }

  .tag-filter-box:focus-within {
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.1);
  }

  .tag-chip-container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
  }

  .tag-chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    background: #e7f1ff;
    color: #0d6efd;
    border-radius: 999px;
    font-size: 0.8rem;
  }

  .tag-chip-remove {
    border: none;
    background: transparent;
    color: inherit;
    font-size: 0.85rem;
    cursor: pointer;
    padding: 0;
    line-height: 1;
  }

  .tag-chip-remove:hover {
    color: #084298;
  }

  #tag-filter-input {
    border: none;
    outline: none;
    width: 200px;
    max-width: 100%;
    font-size: 0.9rem;
    background: transparent;
  }

  #tag-filter-input::placeholder {
    color: #adb5bd;
  }

  .tag-suggestions {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #ced4da;
    border-radius: 0 0 6px 6px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    z-index: 10;
    max-height: 220px;
    overflow-y: auto;
    display: none;
  }

  .tag-suggestions.visible {
    display: block;
  }

  .tag-suggestion-item {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 0.9rem;
  }

  .tag-suggestion-item:hover {
    background: #f1f3f5;
  }
  
  .size-control {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .size-control #size-label {
    display: inline-block;
    min-width: 140px;
    white-space: nowrap;
  }

  .size-control .form-range {
    width: 110px;
    accent-color: #0d6efd;
  }

  .size-control .form-range:focus {
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.15);
  }

  .size-control .form-range::-webkit-slider-runnable-track {
    background: linear-gradient(90deg, #0d6efd 0%, #6ea8fe 100%);
    height: 0.35rem;
    border-radius: 999px;
  }

  .size-control .form-range::-webkit-slider-thumb {
    margin-top: -6px;
    background-color: #0a58ca;
    border: 2px solid #ffffff;
  }

  .size-control .form-range::-moz-range-track {
    background: linear-gradient(90deg, #0d6efd 0%, #6ea8fe 100%);
    height: 0.35rem;
    border-radius: 999px;
  }

  .size-control .form-range::-moz-range-thumb {
    background-color: #0a58ca;
    border: 2px solid #ffffff;
  }
  
  .media-grid {
    display: grid;
    gap: 15px;
    padding: 20px 0;
    transition: all 0.3s ease;
  }
  
  .media-grid.size-small {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 10px;
  }
  
  .media-grid.size-medium {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 15px;
  }
  
  .media-grid.size-large {
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 20px;
  }
  
  .media-card {
    display: block;
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: transform 0.2s, box-shadow 0.2s;
    cursor: pointer;
    text-decoration: none;
    color: inherit;
  }
  
  .media-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  }
  
  .media-thumbnail-wrapper {
    position: relative;
    width: 100%;
    height: 200px;
    background: #f8f9fa;
    overflow: hidden;
    display: flex;
    align-items: stretch;
  }

  .media-grid.size-small .media-thumbnail-wrapper {
    height: 150px;
  }

  .media-grid.size-medium .media-thumbnail-wrapper {
    height: 200px;
  }

  .media-grid.size-large .media-thumbnail-wrapper {
    height: 280px;
  }

  .media-thumbnail {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: opacity 0.25s ease;
    opacity: 0;
  }

  .media-thumbnail-wrapper:not(.is-loading):not(.is-error) .media-thumbnail {
    opacity: 1;
  }

  .thumbnail-loading-indicator {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 8px;
    background: linear-gradient(180deg, rgba(255,255,255,0.92) 0%, rgba(248,249,250,0.92) 100%);
    color: #495057;
    font-size: 0.85rem;
    font-weight: 600;
    transition: opacity 0.25s ease;
    opacity: 0;
    pointer-events: none;
  }

  .thumbnail-loading-indicator .loading-text {
    letter-spacing: 0.02em;
  }

  .media-thumbnail-wrapper.is-loading .thumbnail-loading-indicator,
  .media-thumbnail-wrapper.is-error .thumbnail-loading-indicator {
    opacity: 1;
  }

  .media-thumbnail-wrapper.is-error {
    background: rgba(220, 53, 69, 0.12);
  }

  .media-thumbnail-wrapper.is-error .thumbnail-loading-indicator {
    background: linear-gradient(180deg, rgba(255,240,240,0.95) 0%, rgba(255,230,230,0.95) 100%);
    color: #842029;
  }
  
  .media-overlay {
    position: absolute;
    top: 5px;
    right: 5px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.7rem;
  }
  
  .video-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px;
    border-radius: 50%;
    font-size: 1.2rem;
  }
  
  .media-info {
    padding: 10px;
    background: white;
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  .media-title {
    font-size: 0.9rem;
    margin: 0 0 5px 0;
    white-space: normal;
    overflow-wrap: anywhere;
    word-break: break-word;
    line-height: 1.3;
  }

  .media-meta {
    font-size: 0.8rem;
    color: #6c757d;
    margin: 0;
    overflow-wrap: anywhere;
    word-break: break-word;
    line-height: 1.4;
  }
  
  .loading-spinner {
    text-align: center;
    padding: 40px;
  }
  
  .no-more-data {
    text-align: center;
    padding: 20px;
    color: #6c757d;
    font-style: italic;
  }
  
  .filter-badge {
    background: #007bff;
    color: white;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    margin-left: 5px;
  }
</style>
{% endblock %}

{% block content %}
<div class="controls-bar">
  <div class="d-flex align-items-center">
    <h1 class="h3 mb-0">{{ _("Media Gallery") }}</h1>
    <span id="media-count" class="filter-badge">{{ _("Loading...") }}</span>
  </div>

  <div class="tag-filter">
    <label for="tag-filter-input" class="form-label mb-1">{{ _("Filter by tags") }}</label>
    <div class="tag-filter-box" id="tag-filter-box">
      <div id="selected-tag-filters" class="tag-chip-container empty"></div>
      <input type="text" id="tag-filter-input" placeholder="{{ _("Type to search tags...") }}" autocomplete="off">
      <div id="tag-filter-suggestions" class="tag-suggestions"></div>
    </div>
  </div>

  <div class="view-controls">
    <!-- Filter -->
    <select id="type-filter" class="form-select form-select-sm" style="width: auto;">
      <option value="all">{{ _("All Media") }}</option>
      <option value="photo">{{ _("Photos Only") }}</option>
      <option value="video">{{ _("Videos Only") }}</option>
    </select>
    
    <!-- Thumbnail size -->
    <div class="size-control">
      <label for="size-slider" class="form-label mb-0 me-2" style="font-size: 0.9rem;">{{ _("Thumbnail size") }}</label>
      <input type="range" id="size-slider" class="form-range" min="1" max="3" value="2" style="width: 80px;">
      <span id="size-label" class="text-muted small fw-semibold">{{ _("Medium thumbnails") }}</span>
    </div>

    <!-- Sort order -->
    <select id="sort-order" class="form-select form-select-sm" style="width: auto;">
      <option value="desc">{{ _("Newest First") }}</option>
      <option value="asc">{{ _("Oldest First") }}</option>
    </select>
    
    <!-- Refresh -->
    <button id="refresh-btn" class="btn btn-outline-primary btn-sm">
      <i class="fas fa-refresh"></i> {{ _("Refresh") }}
    </button>
  </div>
</div>

<div id="media-grid" class="media-grid size-medium" data-max-concurrent-loads="4">
  <!-- Media cards are injected dynamically -->
</div>

<div id="loading-indicator" class="loading-spinner" style="display: none;">
  <div class="spinner-border text-primary" role="status">
    <span class="visually-hidden">{{ _("Loading...") }}</span>
  </div>
  <p class="mt-2">{{ _("Loading more media...") }}</p>
</div>

<div id="no-more-data" class="no-more-data" style="display: none;">
  <p>{{ _("All media loaded") }}</p>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const mediaGrid = document.getElementById('media-grid');
  const loadingIndicator = document.getElementById('loading-indicator');
  const noMoreData = document.getElementById('no-more-data');
  const sortOrder = document.getElementById('sort-order');
  const refreshBtn = document.getElementById('refresh-btn');
  const mediaCount = document.getElementById('media-count');
  const tagFilterInput = document.getElementById('tag-filter-input');
  const tagFilterSuggestions = document.getElementById('tag-filter-suggestions');
  const selectedTagFiltersContainer = document.getElementById('selected-tag-filters');
  const tagFilterBox = document.getElementById('tag-filter-box');
  const SEARCH_PARAM_TYPE = 'type';
  const SEARCH_PARAM_ORDER = 'order';
  const SEARCH_PARAM_TAG = 'tag';
  const FILTER_DEFAULTS = { type: 'all', sort: 'desc' };
  const VALID_TYPE_FILTERS = new Set(['all', 'photo', 'video']);
  const VALID_SORT_ORDERS = new Set(['asc', 'desc']);

  let infiniteScroll;
  let totalLoaded = 0;
  let selectedTagFilters = [];
  let tagSuggestionTimeout = null;

  function formatDateTime(isoString) {
    if (!isoString) return '';
    const helper = window.appTime;
    if (helper && typeof helper.formatDateTime === 'function') {
      const formatted = helper.formatDateTime(isoString);
      if (formatted) {
        return formatted;
      }
    }
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) {
      return '';
    }
    const locale = navigator.language || 'en-US';
    return `${date.toLocaleDateString(locale)} ${date.toLocaleTimeString(locale, {
      hour: '2-digit',
      minute: '2-digit'
    })}`;
  }

  function formatFileSize(bytes) {
    if (!bytes || bytes === 0) return '';
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }
    return `${size.toFixed(1)} ${units[unitIndex]}`;
  }

  function renderSelectedTagFilters() {
    if (!selectedTagFiltersContainer) {
      return;
    }

    selectedTagFiltersContainer.innerHTML = '';
    if (selectedTagFilters.length === 0) {
      selectedTagFiltersContainer.classList.add('empty');
      return;
    }

    selectedTagFiltersContainer.classList.remove('empty');
    selectedTagFilters.forEach((tag) => {
      const chip = document.createElement('span');
      chip.className = 'tag-chip';

      const nameSpan = document.createElement('span');
      nameSpan.textContent = tag.name;
      chip.appendChild(nameSpan);

      if (tag.attr && tagAttrLabels[tag.attr]) {
        const attrSpan = document.createElement('span');
        attrSpan.style.fontSize = '0.75rem';
        attrSpan.style.opacity = '0.7';
        attrSpan.textContent = ` (${tagAttrLabels[tag.attr]})`;
        chip.appendChild(attrSpan);
      }

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'tag-chip-remove';
      removeBtn.innerHTML = '&times;';
      removeBtn.setAttribute('aria-label', `${removeTagLabel} ${tag.name}`);
      removeBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        removeTagFilter(tag.id);
      });
      chip.appendChild(removeBtn);

      selectedTagFiltersContainer.appendChild(chip);
    });
  }

  function sanitizeTagForState(tag) {
    if (!tag) {
      return null;
    }
    const tagId = Number(tag.id);
    if (!Number.isInteger(tagId) || tagId <= 0) {
      return null;
    }
    const rawName = typeof tag.name === 'string' ? tag.name.trim() : '';
    const fallbackName = `Tag #${tagId}`;
    const sanitized = {
      id: tagId,
      name: rawName.length > 0 ? rawName : fallbackName,
    };
    if (typeof tag.attr === 'string' && tag.attr.trim().length > 0) {
      sanitized.attr = tag.attr.trim();
    }
    return sanitized;
  }

  function restoreFiltersFromState(state) {
    const filters = state && typeof state === 'object' ? state : {};
    if (typeof typeFilter !== 'undefined' && typeFilter) {
      const candidate = typeof filters.type === 'string' ? filters.type : '';
      typeFilter.value = VALID_TYPE_FILTERS.has(candidate) ? candidate : FILTER_DEFAULTS.type;
    }
    if (sortOrder) {
      const candidate = typeof filters.sort === 'string' ? filters.sort : '';
      sortOrder.value = VALID_SORT_ORDERS.has(candidate) ? candidate : FILTER_DEFAULTS.sort;
    }

    if (Array.isArray(filters.tags)) {
      selectedTagFilters = filters.tags
        .map((tag) => sanitizeTagForState(tag))
        .filter(Boolean);
    } else {
      selectedTagFilters = [];
    }

    renderSelectedTagFilters();
  }

  function buildFilterStateSnapshot() {
    const snapshot = {};

    if (typeof typeFilter !== 'undefined' && typeFilter) {
      const value = typeFilter.value || '';
      if (VALID_TYPE_FILTERS.has(value) && value !== FILTER_DEFAULTS.type) {
        snapshot.type = value;
      }
    }

    if (sortOrder) {
      const sortValue = sortOrder.value || '';
      if (VALID_SORT_ORDERS.has(sortValue) && sortValue !== FILTER_DEFAULTS.sort) {
        snapshot.sort = sortValue;
      }
    }

    if (Array.isArray(selectedTagFilters) && selectedTagFilters.length > 0) {
      snapshot.tags = selectedTagFilters.map((tag) => {
        const entry = { id: tag.id };
        if (typeof tag.name === 'string' && tag.name.length > 0) {
          entry.name = tag.name;
        }
        if (typeof tag.attr === 'string' && tag.attr.length > 0) {
          entry.attr = tag.attr;
        }
        return entry;
      });
    }

    return snapshot;
  }

  function toBase64Url(value) {
    if (typeof value !== 'string' || value.length === 0) {
      return '';
    }

    const encoder = window.TextEncoder ? new window.TextEncoder() : null;
    let binary = '';
    if (encoder) {
      const bytes = encoder.encode(value);
      bytes.forEach((codePoint) => {
        binary += String.fromCharCode(codePoint);
      });
    } else {
      binary = unescape(encodeURIComponent(value));
    }

    const base64 = window.btoa(binary);
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/u, '');
  }

  function fromBase64Url(value) {
    if (typeof value !== 'string' || value.length === 0) {
      return '';
    }

    const base64 = value.replace(/-/g, '+').replace(/_/g, '/');
    const padded = base64 + '==='.slice((base64.length + 3) % 4);

    let binary;
    try {
      binary = window.atob(padded);
    } catch (error) {
      return '';
    }

    if (window.TextDecoder) {
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      try {
        return new window.TextDecoder().decode(bytes);
      } catch (error) {
        return '';
      }
    }

    try {
      return decodeURIComponent(binary.split('').map((char) => `%${(`00${char.charCodeAt(0).toString(16)}`).slice(-2)}`).join(''));
    } catch (error) {
      return '';
    }
  }

  function encodeTagParam(tag) {
    const sanitized = sanitizeTagForState(tag);
    if (!sanitized) {
      return null;
    }

    const parts = [String(sanitized.id)];
    const encodedName = toBase64Url(sanitized.name || '');
    parts.push(encodedName);
    if (sanitized.attr) {
      parts.push(sanitized.attr);
    }
    return parts.join('.');
  }

  function decodeTagParam(value) {
    if (typeof value !== 'string' || value.length === 0) {
      return null;
    }

    const parts = value.split('.');
    const id = Number(parts[0]);
    if (!Number.isInteger(id) || id <= 0) {
      return null;
    }

    const tag = { id };
    const encodedName = parts[1] || '';
    const decodedName = fromBase64Url(encodedName) || '';
    if (decodedName) {
      tag.name = decodedName;
    }
    const attr = parts[2] || '';
    if (attr) {
      tag.attr = attr;
    }
    return sanitizeTagForState(tag);
  }

  function readLegacyHashFilters() {
    const rawHash = window.location.hash || '';
    if (!rawHash) {
      return null;
    }

    const normalized = rawHash.charAt(0) === '#' ? rawHash.slice(1) : rawHash;
    if (!normalized) {
      return null;
    }

    const params = new URLSearchParams(normalized);
    const rawValue = params.get('mediaGallery');
    if (!rawValue) {
      return null;
    }

    let parsed = null;
    const decoded = fromBase64Url(rawValue);
    if (decoded) {
      try {
        parsed = JSON.parse(decoded);
      } catch (error) {
        parsed = null;
      }
    }

    if (!parsed) {
      try {
        parsed = JSON.parse(rawValue);
      } catch (error) {
        parsed = null;
      }
    }

    return parsed && typeof parsed === 'object' ? parsed : null;
  }

  function readFiltersFromQuery() {
    const params = new URLSearchParams(window.location.search || '');
    const state = {};

    const typeCandidate = params.get(SEARCH_PARAM_TYPE) || '';
    if (VALID_TYPE_FILTERS.has(typeCandidate)) {
      state.type = typeCandidate;
    }

    const orderCandidate = params.get(SEARCH_PARAM_ORDER) || '';
    if (VALID_SORT_ORDERS.has(orderCandidate)) {
      state.sort = orderCandidate;
    }

    const tags = params.getAll(SEARCH_PARAM_TAG).map((value) => decodeTagParam(value)).filter(Boolean);
    if (tags.length > 0) {
      state.tags = tags;
    }

    const legacyState = readLegacyHashFilters();
    if (legacyState) {
      if (!state.type && typeof legacyState.type === 'string' && VALID_TYPE_FILTERS.has(legacyState.type)) {
        state.type = legacyState.type;
      }
      if (!state.sort && typeof legacyState.sort === 'string' && VALID_SORT_ORDERS.has(legacyState.sort)) {
        state.sort = legacyState.sort;
      }
      if ((!state.tags || state.tags.length === 0) && Array.isArray(legacyState.tags)) {
        const legacyTags = legacyState.tags
          .map((tag) => sanitizeTagForState(tag))
          .filter(Boolean);
        if (legacyTags.length > 0) {
          state.tags = legacyTags;
        }
      }
    }

    return state;
  }

  function syncFiltersToQuery() {
    const snapshot = buildFilterStateSnapshot();
    const params = new URLSearchParams(window.location.search || '');

    params.delete(SEARCH_PARAM_TYPE);
    params.delete(SEARCH_PARAM_ORDER);
    params.delete(SEARCH_PARAM_TAG);

    if (snapshot.type) {
      params.set(SEARCH_PARAM_TYPE, snapshot.type);
    }
    if (snapshot.sort) {
      params.set(SEARCH_PARAM_ORDER, snapshot.sort);
    }
    if (Array.isArray(snapshot.tags)) {
      snapshot.tags.forEach((tag) => {
        const encoded = encodeTagParam(tag);
        if (encoded) {
          params.append(SEARCH_PARAM_TAG, encoded);
        }
      });
    }

    const queryString = params.toString();
    const pathname = window.location.pathname || '';
    const hash = window.location.hash || '';
    const shouldDropLegacyHash = hash && hash.slice(1).startsWith('mediaGallery=');
    const suffix = shouldDropLegacyHash ? '' : hash;
    const nextUrl = queryString ? `${pathname}?${queryString}${suffix}` : `${pathname}${suffix}`;

    try {
      window.history.replaceState(null, '', nextUrl);
    } catch (error) {
      window.location.replace(nextUrl);
    }
  }

  function hideTagSuggestions() {
    if (!tagFilterSuggestions) {
      return;
    }
    tagFilterSuggestions.classList.remove('visible');
    tagFilterSuggestions.innerHTML = '';
  }

  function showTagSuggestions(items) {
    if (!tagFilterSuggestions) {
      return;
    }

    tagFilterSuggestions.innerHTML = '';
    if (!items || items.length === 0) {
      const emptyItem = document.createElement('div');
      emptyItem.className = 'tag-suggestion-item text-muted';
      emptyItem.textContent = noTagsFoundText;
      tagFilterSuggestions.appendChild(emptyItem);
      tagFilterSuggestions.classList.add('visible');
      return;
    }

    items.forEach((tag) => {
      const item = document.createElement('div');
      item.className = 'tag-suggestion-item';
      const attrLabel = tag.attr && tagAttrLabels[tag.attr] ? ` · ${tagAttrLabels[tag.attr]}` : '';
      item.textContent = `${tag.name}${attrLabel}`;
      item.addEventListener('click', () => {
        addTagFilter(tag);
        tagFilterInput.value = '';
        hideTagSuggestions();
      });
      tagFilterSuggestions.appendChild(item);
    });

    tagFilterSuggestions.classList.add('visible');
  }

  async function fetchTagSuggestions(query) {
    try {
      const response = await window.apiClient.get(`/api/tags?q=${encodeURIComponent(query)}&limit=10`);
      if (!response.ok) {
        throw new Error(`Failed to fetch tag suggestions: ${response.status}`);
      }
      const data = await response.json();
      return data.items || [];
    } catch (error) {
      console.error('Failed to fetch tag suggestions', error);
      return [];
    }
  }

  function addTagFilter(tag) {
    if (selectedTagFilters.some((t) => t.id === tag.id)) {
      return;
    }
    selectedTagFilters.push(tag);
    renderSelectedTagFilters();
    restartMediaQuery();
  }

  function removeTagFilter(tagId) {
    selectedTagFilters = selectedTagFilters.filter((tag) => tag.id !== tagId);
    renderSelectedTagFilters();
    restartMediaQuery();
  }

  function scheduleTagSuggestionFetch(value) {
    clearTimeout(tagSuggestionTimeout);
    if (!value) {
      hideTagSuggestions();
      return;
    }

    tagSuggestionTimeout = setTimeout(async () => {
      const suggestions = await fetchTagSuggestions(value);
      const available = suggestions.filter(
        (suggestion) => !selectedTagFilters.some((tag) => tag.id === suggestion.id)
      );
      showTagSuggestions(available);
    }, 200);
  }

  const sourceLabels = {
    local: '{{ _("Local import")|escapejs }}',
    google_photos: '{{ _("Google Photos")|escapejs }}'
  };
  const unknownSourceLabel = '{{ _("Unknown source")|escapejs }}';
  const videoLabel = '{{ _("Video")|escapejs }}';
  const photoLabel = '{{ _("Photo")|escapejs }}';
  const removeTagLabel = '{{ _("Remove")|escapejs }}';
  const noTagsFoundText = '{{ _("No tags found")|escapejs }}';
  const itemsLabel = '{{ _("items")|escapejs }}';
  const failedToLoadMediaText = '{{ _("Failed to load media. Please try again.")|escapejs }}';
  const tagAttrLabels = {
    person: '{{ _("Person")|escapejs }}',
    place: '{{ _("Place")|escapejs }}',
    thing: '{{ _("Thing")|escapejs }}'
  };
  const nowLoadingLabel = '{{ _("Now Loading..")|escapejs }}';
  const failedToLoadThumbnailText = '{{ _("Failed to load thumbnail")|escapejs }}';
  const DEFAULT_MAX_CONCURRENT_MEDIA_LOADS = 4;

  function createLimitedConcurrencyQueue(options = {}) {
    const normalized = Math.max(1, Number(options.concurrency) || DEFAULT_MAX_CONCURRENT_MEDIA_LOADS);
    const pending = [];
    let activeCount = 0;

    const runNext = () => {
      if (activeCount >= normalized) {
        return;
      }
      const next = pending.shift();
      if (!next) {
        return;
      }
      activeCount += 1;
      const { task, resolve, reject } = next;
      Promise.resolve()
        .then(task)
        .then(resolve)
        .catch((error) => {
          console.error('Media load task failed', error);
          reject?.(error);
        })
        .finally(() => {
          activeCount = Math.max(0, activeCount - 1);
          runNext();
        });
    };

    return {
      enqueue(task) {
        let resolveFn;
        let rejectFn;
        const promise = new Promise((resolve, reject) => {
          resolveFn = resolve;
          rejectFn = reject;
        });
        pending.push({ task, resolve: resolveFn, reject: rejectFn });
        runNext();
        return promise;
      },
      clear(filterFn) {
        if (typeof filterFn === 'function') {
          for (let i = pending.length - 1; i >= 0; i -= 1) {
            if (filterFn(pending[i])) {
              pending.splice(i, 1);
            }
          }
        } else {
          pending.length = 0;
        }
      }
    };
  }

  function createThumbnailLoader(options = {}) {
    const queue = createLimitedConcurrencyQueue({ concurrency: options.concurrency });

    const setLoadingText = (wrapper, text) => {
      const textElement = wrapper?.querySelector('.thumbnail-loading-indicator .loading-text');
      if (textElement) {
        textElement.textContent = text;
      }
    };

    return {
      load(wrapper, url) {
        if (!wrapper) {
          return Promise.resolve();
        }

        const imageElement = wrapper.querySelector('img.media-thumbnail');
        if (!imageElement) {
          return Promise.resolve();
        }

        if (!url) {
          wrapper.classList.remove('is-loading');
          wrapper.classList.add('is-error');
          setLoadingText(wrapper, failedToLoadThumbnailText);
          return Promise.resolve();
        }

        if (
          imageElement.dataset.thumbnailRequestedUrl === url &&
          imageElement.dataset.thumbnailLoaded === 'true'
        ) {
          wrapper.classList.remove('is-loading');
          wrapper.classList.remove('is-error');
          setLoadingText(wrapper, nowLoadingLabel);
          return Promise.resolve();
        }

        imageElement.dataset.thumbnailRequestedUrl = url;
        imageElement.dataset.thumbnailLoaded = 'false';
        wrapper.classList.add('is-loading');
        wrapper.classList.remove('is-error');
        setLoadingText(wrapper, nowLoadingLabel);
        imageElement.removeAttribute('src');

        return queue
          .enqueue(
            () =>
              new Promise((resolve) => {
                const image = new Image();
                image.decoding = 'async';
                image.onload = () => {
                  if (imageElement.isConnected && imageElement.dataset.thumbnailRequestedUrl === url) {
                    imageElement.src = url;
                    imageElement.dataset.thumbnailLoaded = 'true';
                    wrapper.classList.remove('is-loading');
                    wrapper.classList.remove('is-error');
                    setLoadingText(wrapper, nowLoadingLabel);
                  }
                  resolve();
                };
                image.onerror = () => {
                  if (imageElement.isConnected && imageElement.dataset.thumbnailRequestedUrl === url) {
                    wrapper.classList.add('is-error');
                    setLoadingText(wrapper, failedToLoadThumbnailText);
                    imageElement.dataset.thumbnailLoaded = 'false';
                    imageElement.removeAttribute('src');
                  }
                  wrapper.classList.remove('is-loading');
                  resolve();
                };
                image.src = url;
              })
          )
          .catch((error) => {
            console.error('Thumbnail load failed', error);
          });
      },
      reset() {
        queue.clear();
      }
    };
  }

  function resolveMediaThumbnailUrl(media) {
    if (!media) {
      return null;
    }
    if (typeof media.thumbnailUrl === 'string' && media.thumbnailUrl) {
      return media.thumbnailUrl;
    }
    if (typeof media.thumbnail_url === 'string' && media.thumbnail_url) {
      return media.thumbnail_url;
    }
    if (media.id !== null && media.id !== undefined) {
      return `/api/media/${media.id}/thumbnail?size=256`;
    }
    return null;
  }

  const maxConcurrentMediaLoads = (() => {
    const raw = mediaGrid?.dataset?.maxConcurrentLoads;
    const parsed = Number.parseInt(raw || '', 10);
    if (Number.isFinite(parsed) && parsed > 0) {
      return parsed;
    }
    return DEFAULT_MAX_CONCURRENT_MEDIA_LOADS;
  })();

  const mediaThumbnailLoader = createThumbnailLoader({ concurrency: maxConcurrentMediaLoads });

  function createMediaCard(media) {
    const card = document.createElement('a');
    card.className = 'media-card';
    card.href = `/photo-view/media/${media.id}`;

    const thumbnailWrapper = document.createElement('div');
    thumbnailWrapper.className = 'media-thumbnail-wrapper is-loading';
    const thumbnailImage = document.createElement('img');
    thumbnailImage.className = 'media-thumbnail';
    thumbnailImage.alt = media.filename || 'Media';
    thumbnailImage.loading = 'lazy';
    thumbnailImage.decoding = 'async';

    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'thumbnail-loading-indicator';
    loadingIndicator.innerHTML = `
      <div class="spinner-border spinner-border-sm text-primary" role="status" aria-hidden="true"></div>
      <span class="loading-text">${nowLoadingLabel}</span>
    `;

    thumbnailWrapper.appendChild(thumbnailImage);
    thumbnailWrapper.appendChild(loadingIndicator);
    card.appendChild(thumbnailWrapper);

    const isVideo = media.isVideo || media.is_video;

    const sourceText = media.source_label || sourceLabels[media.source_type] || unknownSourceLabel;
    const accountText = media.account_email ? ` (${media.account_email})` : '';
    const metaParts = [];
    const typeLabel = isVideo ? videoLabel : photoLabel;
    const sizeLabel = formatFileSize(media.bytes);

    if (sizeLabel) {
      metaParts.push(sizeLabel);
    }
    if (sourceText) {
      metaParts.push(`${sourceText}${accountText}`);
    }
    metaParts.push(typeLabel);
    if (media.camera_make) {
      metaParts.push(media.camera_make);
    }

    const metaLine = metaParts.filter(Boolean).join(' • ');

    if (media.width && media.height) {
      const dimensionOverlay = document.createElement('div');
      dimensionOverlay.className = 'media-overlay';
      dimensionOverlay.textContent = `${media.width}×${media.height}`;
      card.appendChild(dimensionOverlay);
    }

    if (isVideo) {
      const videoOverlay = document.createElement('div');
      videoOverlay.className = 'video-overlay';
      videoOverlay.innerHTML = '<i class="fas fa-play"></i>';
      card.appendChild(videoOverlay);
    }

    const infoContainer = document.createElement('div');
    infoContainer.className = 'media-info';

    const title = document.createElement('h6');
    title.className = 'media-title';
    title.textContent = formatDateTime(media.shot_at) || 'Unknown Date';

    const meta = document.createElement('p');
    meta.className = 'media-meta';
    meta.textContent = metaLine;

    infoContainer.appendChild(title);
    infoContainer.appendChild(meta);
    card.appendChild(infoContainer);

    const thumbnailUrl = resolveMediaThumbnailUrl(media);
    mediaThumbnailLoader.load(thumbnailWrapper, thumbnailUrl);

    return card;
  }

  function restartMediaQuery(options = {}) {
    if (!options.skipQueryUpdate) {
      syncFiltersToQuery();
    }

    if (infiniteScroll) {
      infiniteScroll.destroy();
    }
    initializeInfiniteScroll();
  }

  function initializeInfiniteScroll() {
    mediaThumbnailLoader.reset();

    // Read the current filter settings
    const typeValue =
      typeof typeFilter !== 'undefined' && typeFilter && VALID_TYPE_FILTERS.has(typeFilter.value)
        ? typeFilter.value
        : FILTER_DEFAULTS.type;
    const sortValue =
      sortOrder && VALID_SORT_ORDERS.has(sortOrder.value)
        ? sortOrder.value
        : FILTER_DEFAULTS.sort;

    // Build the request parameters
    const parameters = { order: sortValue };
    if (typeValue !== FILTER_DEFAULTS.type) {
      parameters.type = typeValue;
    }
    if (selectedTagFilters.length > 0) {
      parameters.tags = selectedTagFilters.map((tag) => tag.id).join(',');
    }
    
    const paginationClient = new PaginationClient({
      baseUrl: '/api/media',
      pageSize: 24,
      parameters: parameters,
      onItemsLoaded: (items, meta) => {
        if (meta.isFirstPage) {
          mediaGrid.innerHTML = '';
          totalLoaded = 0;
        }

        const fragment = document.createDocumentFragment();
        items.forEach((media) => {
          const card = createMediaCard(media);
          if (card) {
            fragment.appendChild(card);
            totalLoaded += 1;
          }
        });

        if (fragment.childNodes.length > 0) {
          mediaGrid.appendChild(fragment);
        }

        mediaCount.textContent = `${totalLoaded} ${itemsLabel}`;

        if (items.length === 0 && meta.isFirstPage) {
          mediaGrid.innerHTML = `
            <div class="text-center text-muted p-5">
              <h4>{{ _("No media found") }}</h4>
              <p>{{ _("Try adjusting your filters or add more media to your library.") }}</p>
            </div>
          `.trim();
        }
      },
      onError: (error) => {
        console.error('Media loading error:', error);
        const errorDiv = document.createElement('div');
        errorDiv.className = 'alert alert-danger';
        errorDiv.textContent = failedToLoadMediaText;
        mediaGrid.appendChild(errorDiv);
      }
    });

    infiniteScroll = new InfiniteScrollHelper({
      paginationClient: paginationClient,
      loadingIndicator: loadingIndicator,
      noMoreDataIndicator: noMoreData,
      container: document.body,
      threshold: 200
    });

    infiniteScroll.start();
  }

  // Handle size changes
  const sizeSlider = document.getElementById('size-slider');
  const sizeLabel = document.getElementById('size-label');
  const sizeClasses = ['size-small', 'size-medium', 'size-large'];
  const sizeDescriptions = {
    1: '{{ _("Compact")|escapejs }}',
    2: '{{ _("Medium")|escapejs }}',
    3: '{{ _("Large")|escapejs }}'
  };

  function applyGridSize(value) {
    const index = Math.min(Math.max(parseInt(value, 10) || 2, 1), 3) - 1;
    mediaGrid.className = `media-grid ${sizeClasses[index]}`;
    if (sizeLabel) {
      const label = sizeDescriptions[index + 1] || '';
      sizeLabel.textContent = label;
      sizeLabel.classList.toggle('d-none', !label);
    }
  }

  if (sizeSlider) {
    sizeSlider.addEventListener('input', (event) => {
      applyGridSize(event.target.value);
    });
    applyGridSize(sizeSlider.value);
  }

  // Filter change
  const typeFilter = document.getElementById('type-filter');
  if (typeFilter) {
    typeFilter.addEventListener('change', () => {
      restartMediaQuery();
    });
  }

  // Sort order change handler
  if (sortOrder) {
    sortOrder.addEventListener('change', () => {
      restartMediaQuery();
    });
  }

  // Refresh button handler
  if (refreshBtn) {
    refreshBtn.addEventListener('click', () => {
      restartMediaQuery();
    });
  }

  if (tagFilterInput) {
    tagFilterInput.addEventListener('input', (event) => {
      scheduleTagSuggestionFetch(event.target.value.trim());
    });

    tagFilterInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        if (tagFilterSuggestions) {
          const firstSuggestion = tagFilterSuggestions.querySelector('.tag-suggestion-item');
          if (firstSuggestion) {
            firstSuggestion.click();
          }
        }
      } else if (event.key === 'Escape') {
        hideTagSuggestions();
        tagFilterInput.value = '';
      }
    });

    tagFilterInput.addEventListener('focus', () => {
      const value = tagFilterInput.value.trim();
      if (value) {
        scheduleTagSuggestionFetch(value);
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (tagFilterBox && !tagFilterBox.contains(event.target)) {
      hideTagSuggestions();
    }
  });

  const initialFilters = readFiltersFromQuery();
  restoreFiltersFromState(initialFilters);
  syncFiltersToQuery();
  initializeInfiniteScroll();
});
</script>
{% endblock %}
