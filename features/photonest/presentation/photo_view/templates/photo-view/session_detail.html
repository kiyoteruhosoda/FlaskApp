{% extends 'base.html' %}
{% block title %}Session Details{% endblock %}

{% block extra_head %}
<script src="{{ url_for('static', filename='js/filter-state.js') }}"></script>
<script src="{{ url_for('static', filename='js/pagination.js') }}"></script>
{% endblock %}

{% block content %}
<div class="d-flex flex-column flex-lg-row gap-2 align-items-lg-center justify-content-lg-between mb-3">
  <div>
    <h1 id="session-title" class="mb-1">{{ _("Session Details") }}</h1>
    <p id="session-subtitle" class="text-muted small mb-0 d-none"></p>
  </div>
  <a href="/photo-view/session" class="btn btn-outline-secondary btn-sm">
    <i class="bi bi-arrow-left"></i> {{ _("Back to Sessions") }}
  </a>
</div>

<div class="mb-3">
  <div class="d-flex flex-wrap gap-2">
    <button id="btn-import-start" class="btn btn-primary" disabled aria-disabled="true">
      {{ _("Start Import") }}
    </button>
    <button id="btn-local-import-stop" class="btn btn-outline-danger d-none" type="button">
      <i class="bi bi-stop-circle"></i> {{ _("Stop Local Import") }}
    </button>
  </div>
  <div id="local-import-status" class="mt-2 small text-muted d-none"></div>
  <div id="session-info" class="text-muted mt-2">
    {{ _("Loading session info...") }}
  </div>
  <div id="local-import-tasks" class="mt-3 d-none"></div>
</div>

<div id="import-status" class="mt-3" aria-live="polite"></div>

<div class="mt-4">
  <h2>{{ _("Selected Files") }}</h2>
  <p class="text-muted small mb-2">
    <i class="bi bi-info-circle"></i> {{ _("Failed files will be retried up to three times.") }}
  </p>
  <div id="selection-counts" class="mb-2 text-muted">{{ _("Loading...") }}</div>
  <div class="card card-body bg-body-tertiary border-0 mb-3">
    <form id="selection-filter-form" class="row g-2 align-items-end">
      <div class="col-12 col-md-6 col-lg-4">
        <label for="selection-filter-search" class="form-label small text-muted mb-1">{{ _("Filter by keyword") }}</label>
        <div class="input-group">
          <input id="selection-filter-search" type="search" class="form-control form-control-sm" placeholder="{{ _("Search filename or ID") }}" autocomplete="off">
          <button type="button" id="selection-filter-search-btn" class="btn btn-outline-primary btn-sm">
            <span id="selection-filter-search-spinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
            <span id="selection-filter-search-btn-label">{{ _("Search") }}</span>
          </button>
        </div>
      </div>
      <div class="col-12 col-md-4 col-lg-3">
        <label for="selection-filter-status" class="form-label small text-muted mb-1">{{ _("Status filter") }}</label>
        <select id="selection-filter-status" class="form-select form-select-sm">
          <option value="">{{ _("All statuses") }}</option>
          <option value="pending">{{ _("Pending") }}</option>
          <option value="enqueued">{{ _("Enqueued") }}</option>
          <option value="running">{{ _("Running") }}</option>
          <option value="imported">{{ _("Imported") }}</option>
          <option value="failed">{{ _("Failed") }}</option>
          <option value="dup">{{ _("Duplicate") }}</option>
          <option value="skipped">{{ _("Skipped") }}</option>
        </select>
      </div>
      <div class="col-12 col-md-2 col-lg-auto">
        <button type="button" id="selection-filter-reset" class="btn btn-outline-secondary btn-sm w-100">
          <i class="bi bi-x-circle"></i> {{ _("Reset filters") }}
        </button>
      </div>
    </form>
  </div>
  <div class="table-responsive">
    <table class="table table-sm">
      <thead>
        <tr>
          <th>{{ _("File") }}</th>
          <th>{{ _("Status") }}</th>
          <th>{{ _("Attempts") }}</th>
          <th>{{ _("Error") }}</th>
          <th>{{ _("Logs") }}</th>
        </tr>
      </thead>
      <tbody id="selection-body">
        <!-- アイテムが動的に追加されます -->
      </tbody>
    </table>
  </div>
  <div id="selection-pagination" class="d-flex flex-column flex-md-row gap-2 align-items-md-center justify-content-md-between mt-2 d-none">
    <div id="selection-pagination-status" class="small text-muted"></div>
    <div class="d-flex align-items-center gap-2">
      <button id="selection-pagination-load" type="button" class="btn btn-outline-primary btn-sm">
        <span class="spinner-border spinner-border-sm align-text-bottom me-1 d-none" id="selection-pagination-spinner" role="status" aria-hidden="true"></span>
        {{ _("Load more") }}
      </button>
    </div>
  </div>
</div>

<div id="local-import-file-progress" class="mt-4 d-none">
  <h2>{{ _("File Progress") }}</h2>
  <p class="text-muted small mb-2">
    <i class="bi bi-info-circle"></i> {{ _("Latest worker log status for each processed file.") }}
  </p>
    <div class="table-responsive">
      <table class="table table-sm mb-0">
      <thead>
        <tr>
          <th style="width: 28%">{{ _("File") }}</th>
          <th style="width: 16%">{{ _("State") }}</th>
          <th style="width: 16%">{{ _("Step") }}</th>
          <th style="width: 18%">{{ _("Updated") }}</th>
          <th>{{ _("Message") }}</th>
        </tr>
      </thead>
      <tbody id="local-import-file-progress-body">
        <tr id="local-import-file-progress-empty">
          <td colspan="5" class="text-center text-muted py-3">{{ _("No file activity yet.") }}</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

  <div id="local-import-logs-section" class="mt-4 d-none">
    <h2>{{ _("Import Logs") }}</h2>
    <div class="d-flex flex-column flex-lg-row gap-2 align-items-lg-center justify-content-lg-between mb-2">
      <p class="text-muted small mb-0">
        <i class="bi bi-info-circle"></i> {{ _("ZIP extraction and file processing logs appear here while local import runs.") }}
      </p>
      <button type="button" id="local-import-log-download" class="btn btn-outline-secondary btn-sm d-none">
        <i class="bi bi-download"></i> {{ _("Download full logs (ZIP)") }}
      </button>
    </div>
    <div class="table-responsive">
      <div id="local-import-log-filter" class="alert alert-info py-2 px-3 d-none" role="status">
        <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-2">
          <div id="local-import-log-filter-text" class="small mb-0"></div>
          <button type="button" id="local-import-log-filter-clear" class="btn btn-outline-primary btn-sm">
            <i class="bi bi-x-circle"></i> {{ _("Show all logs") }}
          </button>
        </div>
      </div>
      <table class="table table-sm mb-0">
      <thead>
        <tr>
          <th style="width: 18%">{{ _("Time") }}</th>
          <th style="width: 18%">{{ _("Event") }}</th>
          <th style="width: 14%">{{ _("Status") }}</th>
          <th style="width: 12%">{{ _("Level") }}</th>
          <th>{{ _("Message") }}</th>
        </tr>
      </thead>
      <tbody id="local-import-log-body">
        <tr id="local-import-log-empty">
          <td colspan="5" class="text-center text-muted py-3">{{ _("No logs yet.") }}</td>
        </tr>
      </tbody>
    </table>
  </div>
    <div id="local-import-log-pagination" class="d-flex flex-column flex-md-row gap-2 align-items-md-center justify-content-md-between mt-2 d-none">
      <div id="local-import-log-pagination-status" class="small text-muted"></div>
      <div class="d-flex align-items-center gap-2">
        <button type="button" id="local-import-log-pagination-load" class="btn btn-outline-primary btn-sm">
          <span class="spinner-border spinner-border-sm align-text-bottom me-1 d-none" id="local-import-log-pagination-spinner" role="status" aria-hidden="true"></span>
          {{ _("Load more") }}
        </button>
      </div>
    </div>
</div>

<div id="server-data"
     data-picker-session-id="{{ picker_session_id or '' }}"
     style="display: none;"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  function escapeHtml(value) {
    if (value === null || value === undefined) {
      return '';
    }
    return String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function resolveSessionId() {
    const params = new URLSearchParams(window.location.search);
    const fromQuery = params.get('session_id');
    if (fromQuery) return fromQuery;
    const serverDataEl = document.getElementById('server-data');
    const fromServer = serverDataEl.getAttribute('data-picker-session-id');
    return fromServer || '';
  }

  const pickerSessionId = resolveSessionId();
  if (!pickerSessionId) {
    window.location.href = '/photo-view/session';
    return;
  }

  if (/^\d+$/.test(pickerSessionId)) {
    console.warn('Numeric session ID detected, redirecting to sessions list');
    window.location.href = '/photo-view/session';
    return;
  }

  const importBtn = document.getElementById('btn-import-start');
  const stopLocalImportBtn = document.getElementById('btn-local-import-stop');
  const statusEl = document.getElementById('import-status');
  const selectionBody = document.getElementById('selection-body');
  const countsEl = document.getElementById('selection-counts');
  const sessionInfoEl = document.getElementById('session-info');
  const sessionTitleEl = document.getElementById('session-title');
  const sessionSubtitleEl = document.getElementById('session-subtitle');
  const localImportStatusEl = document.getElementById('local-import-status');
  const localImportTasksEl = document.getElementById('local-import-tasks');
  const fileProgressSection = document.getElementById('local-import-file-progress');
  const fileProgressBody = document.getElementById('local-import-file-progress-body');
  const logSection = document.getElementById('local-import-logs-section');
  const logBody = document.getElementById('local-import-log-body');
  const logDownloadButton = document.getElementById('local-import-log-download');
  const logFilterNoticeEl = document.getElementById('local-import-log-filter');
  const logFilterNoticeTextEl = document.getElementById('local-import-log-filter-text');
  const logFilterClearButton = document.getElementById('local-import-log-filter-clear');
  const logPaginationContainer = document.getElementById('local-import-log-pagination');
  const logPaginationStatusEl = document.getElementById('local-import-log-pagination-status');
  const logPaginationButton = document.getElementById('local-import-log-pagination-load');
  const logPaginationSpinner = document.getElementById('local-import-log-pagination-spinner');
  const selectionPaginationEl = document.getElementById('selection-pagination');
  const selectionPaginationStatusEl = document.getElementById('selection-pagination-status');
  const selectionPaginationButton = document.getElementById('selection-pagination-load');
  const selectionPaginationSpinner = document.getElementById('selection-pagination-spinner');
  const selectionFilterForm = document.getElementById('selection-filter-form');
  const selectionFilterSearchInput = document.getElementById('selection-filter-search');
  const selectionFilterStatusSelect = document.getElementById('selection-filter-status');
  const selectionFilterResetButton = document.getElementById('selection-filter-reset');
  const selectionFilterSearchBtn = document.getElementById('selection-filter-search-btn');
  const selectionFilterSearchSpinner = document.getElementById('selection-filter-search-spinner');
  const selectionFilterSearchBtnLabel = document.getElementById('selection-filter-search-btn-label');
  const filterStateApi = window.filterState || null;
  const SESSION_FILTER_SECTION = 'sessionDetail';

  function applySessionFiltersFromState(state) {
    const filters = state && typeof state === 'object' ? state : {};
    const matchesSession = filters.sessionId === pickerSessionId;

    if (selectionFilterSearchInput) {
      const value = matchesSession && typeof filters.search === 'string' ? filters.search : '';
      selectionFilterSearchInput.value = value;
    }

    if (selectionFilterStatusSelect) {
      const statusValue = matchesSession && typeof filters.status === 'string' ? filters.status : '';
      selectionFilterStatusSelect.value = statusValue;
    }
  }

  function buildSessionFilterSnapshot() {
    if (!pickerSessionId) {
      return null;
    }

    const snapshot = { sessionId: pickerSessionId };
    let hasFilter = false;

    if (selectionFilterSearchInput) {
      const searchValue = selectionFilterSearchInput.value.trim();
      if (searchValue.length > 0) {
        snapshot.search = searchValue;
        hasFilter = true;
      }
    }

    if (selectionFilterStatusSelect) {
      const statusValue = selectionFilterStatusSelect.value;
      if (statusValue) {
        snapshot.status = statusValue;
        hasFilter = true;
      }
    }

    return hasFilter ? snapshot : null;
  }

  function syncSessionFiltersToHash() {
    if (!filterStateApi || typeof filterStateApi.writeSection !== 'function') {
      return;
    }

    const snapshot = buildSessionFilterSnapshot();
    if (snapshot) {
      filterStateApi.writeSection(SESSION_FILTER_SECTION, snapshot);
    } else {
      filterStateApi.writeSection(SESSION_FILTER_SECTION, null);
    }
  }
  const viewErrorDetailsLabel = '{{ _("View error details") }}';
  const logDownloadDefaultHtml = logDownloadButton ? logDownloadButton.innerHTML : '';
  const logDownloadPreparingLabel = '{{ _("Preparing download...") }}';
  const logDownloadFailedMessage = '{{ _("Failed to download logs.") }}';
  const logDownloadLoadingHtml = `<span class="spinner-border spinner-border-sm align-text-bottom me-2" role="status" aria-hidden="true"></span>${escapeHtml(logDownloadPreparingLabel)}`;
  const viewFileLogsLabel = '{{ _("View file logs") }}';
  const logFilterActivePrefix = '{{ _("Log filter active") }}';
  const logFilterActiveForLabel = '{{ _("Showing logs for") }}';
  const showAllLogsLabel = '{{ _("Show all logs") }}';
  const logFilterUnavailableMessage = '{{ _("No logs available for this file yet.") }}';

  const selectionStatusLabels = {
    pending: '{{ _("Pending") }}',
    enqueued: '{{ _("Enqueued") }}',
    running: '{{ _("Running") }}',
    imported: '{{ _("Imported") }}',
    failed: '{{ _("Failed") }}',
    dup: '{{ _("Duplicate") }}',
    skipped: '{{ _("Skipped") }}'
  };

  const sessionStatusLabels = {
    pending: '{{ _("Pending") }}',
    ready: '{{ _("Ready") }}',
    expanding: '{{ _("Expanding") }}',
    processing: '{{ _("Processing") }}',
    enqueued: '{{ _("Enqueued") }}',
    importing: '{{ _("Importing") }}',
    imported: '{{ _("Imported") }}',
    canceled: '{{ _("Canceled") }}',
    expired: '{{ _("Expired") }}',
    error: '{{ _("Error") }}',
    failed: '{{ _("Failed") }}',
    progress: '{{ _("In progress") }}',
    completed: '{{ _("Completed") }}',
    idle: '{{ _("Idle") }}'
  };

  const sessionStageLabels = {
    expanding: '{{ _("Expanding") }}',
    processing: '{{ _("Processing") }}',
    importing: '{{ _("Importing") }}',
    progress: '{{ _("In progress") }}',
    completed: '{{ _("Completed") }}',
    error: '{{ _("Error") }}',
    canceled: '{{ _("Canceled") }}'
  };

  const fileTaskStateLabels = {
    processing: '{{ _("Processing") }}',
    metadata: '{{ _("Metadata analysis") }}',
    thumbnail: '{{ _("Thumbnail generation") }}',
    storing: '{{ _("File placement") }}',
    success: '{{ _("Completed") }}',
    error: '{{ _("Error") }}',
    skipped: '{{ _("Skipped") }}',
    duplicate: '{{ _("Duplicate") }}',
    warning: '{{ _("Attention") }}'
  };

  const progressStepLabels = {
    1: '{{ _("Started") }}',
    2: '{{ _("Metadata analysis") }}',
    3: '{{ _("Thumbnail generation") }}',
    4: '{{ _("File placement") }}',
    5: '{{ _("Completed") }}',
    9: '{{ _("Error") }}'
  };

  const noFileTasksMessage = '{{ _("No file activity yet.") }}';
  const unknownLabel = '{{ _("Unknown") }}';

  const taskLabelDefault = '{{ _("Task") }}';
  const taskCountLabels = {
    total: '{{ _("Total") }}',
    success: '{{ _("Success") }}',
    skipped: '{{ _("Skipped") }}',
    failed: '{{ _("Failed") }}',
    pending: '{{ _("Pending") }}'
  };
  const taskAttentionLabel = '{{ _("Attention") }}';
  const taskRetryScheduledLabel = '{{ _("Retry scheduled") }}';
  const taskHiddenEntriesLabel = '{{ _("Additional items hidden") }}';

  const noLogsMessage = '{{ _("No logs yet.") }}';
  const LOG_PAGE_SIZE = {{ session_log_page_size|default(100)|int }};
  const LOG_PAGE_MAX = {{ session_log_max_limit|default(500)|int }};
  const FILE_PROGRESS_MAX_ITEMS = 100;

  const localImportRunningMessage = '{{ _("Local import is running. You can stop it if needed.") }}';
  const localImportCancelingMessage = '{{ _("Canceling local import...") }}';
  const localImportCanceledMessage = '{{ _("Local import was canceled.") }}';
  const localImportStopFailedMessage = '{{ _("Failed to stop local import.") }}';
  const localImportCancelConfirmMessage = '{{ _("Are you sure you want to cancel the local import?") }}';

  let selectionFilterSearchDebounce = null;
  let selectionSearchLoading = false;

  function setSelectionSearchLoading(isLoading) {
    selectionSearchLoading = isLoading;
    if (selectionFilterSearchSpinner) {
      selectionFilterSearchSpinner.classList.toggle('d-none', !isLoading);
    }
    if (selectionFilterSearchBtnLabel) {
      selectionFilterSearchBtnLabel.style.display = isLoading ? 'none' : '';
    }
    if (selectionFilterSearchBtn) {
      selectionFilterSearchBtn.disabled = isLoading;
      selectionFilterSearchBtn.classList.toggle('disabled', isLoading);
    }
    if (selectionFilterSearchInput) {
      selectionFilterSearchInput.disabled = isLoading;
    }
    if (selectionFilterStatusSelect) {
      selectionFilterStatusSelect.disabled = isLoading;
    }
  }

  function setSelectionFilterSearchBusy(isBusy) {
    if (!selectionFilterSearchBtn || !selectionFilterSearchSpinner || !selectionFilterSearchBtnLabel) {
      return;
    }

    if (isBusy) {
      selectionFilterSearchSpinner.classList.remove('d-none');
      selectionFilterSearchBtnLabel.classList.add('d-none');
      selectionFilterSearchBtn.disabled = true;
      selectionFilterSearchBtn.classList.add('disabled');
      selectionFilterSearchBtn.setAttribute('aria-busy', 'true');
    } else {
      selectionFilterSearchSpinner.classList.add('d-none');
      selectionFilterSearchBtnLabel.classList.remove('d-none');
      selectionFilterSearchBtn.disabled = false;
      selectionFilterSearchBtn.classList.remove('disabled');
      selectionFilterSearchBtn.removeAttribute('aria-busy');
    }
  }

  function getStatusBadgeClass(status) {
    switch (status) {
      case 'pending': return 'secondary';
      case 'enqueued': return 'info';
      case 'running': return 'warning';
      case 'imported': return 'success';
      case 'failed': return 'danger';
      case 'dup': return 'light text-dark border border-secondary-subtle';
      default: return 'secondary';
    }
  }

  function getSessionBadgeClass(status) {
    switch (status) {
      case 'pending': return 'secondary';
      case 'ready': return 'primary';
      case 'expanding': return 'warning';
      case 'processing': return 'warning';
      case 'importing': return 'info';
      case 'imported': return 'success';
      case 'expired': return 'danger';
      case 'error':
      case 'failed':
        return 'danger';
      default:
        return 'secondary';
    }
  }

  function getLevelBadgeClass(level) {
    switch ((level || '').toUpperCase()) {
      case 'ERROR':
      case 'CRITICAL':
        return 'danger';
      case 'WARNING':
        return 'warning';
      case 'INFO':
        return 'info';
      case 'DEBUG':
        return 'secondary';
      default:
        return 'secondary';
    }
  }

  function getStatusBadgeClass(status) {
    switch ((status || '').toLowerCase()) {
      case 'success':
      case 'completed':
      case 'extracted':
      case 'imported':
        return 'success';
      case 'processing':
      case 'running':
      case 'scanning':
      case 'queued':
        return 'primary';
      case 'copied':
      case 'cleaned':
      case 'duplicate':
      case 'skipped':
      case 'detected':
        return 'secondary';
      case 'warning':
      case 'retrying':
      case 'empty':
        return 'warning';
      case 'failed':
      case 'error':
      case 'missing':
      case 'unsupported':
        return 'danger';
      case 'canceled':
        return 'dark';
      default:
        return 'secondary';
    }
  }

  function getFileTaskBadgeClass(state) {
    switch ((state || '').toLowerCase()) {
      case 'success':
        return 'success';
      case 'error':
        return 'danger';
      case 'warning':
        return 'warning';
      case 'duplicate':
        return 'info';
      case 'skipped':
        return 'secondary';
      case 'thumbnail':
        return 'primary';
      case 'metadata':
      case 'storing':
      case 'processing':
      default:
        return 'secondary';
    }
  }

  function resolveStatusLabel(status) {
    const normalized = (status || '').toString().toLowerCase();
    return sessionStageLabels[normalized] || sessionStatusLabels[normalized] || status || '-';
  }

  function renderLocalImportTasks(stats = {}) {
    if (!localImportTasksEl) {
      return;
    }

    const tasks = Array.isArray(stats.tasks) ? stats.tasks : [];
    if (!isLocalImport || tasks.length === 0) {
      localImportTasksEl.classList.add('d-none');
      localImportTasksEl.innerHTML = '';
      return;
    }

    localImportTasksEl.classList.remove('d-none');

    const sections = tasks.map((task) => {
      const statusValue = (task.status || '').toString();
      const statusLabel = resolveStatusLabel(statusValue);
      const badgeClass = getStatusBadgeClass(statusValue);
      const counts = task.counts || {};
      const countEntries = [];

      ['total', 'success', 'skipped', 'failed', 'pending'].forEach((key) => {
        const label = taskCountLabels[key];
        const rawValue = counts[key];
        if (label && typeof rawValue === 'number') {
          countEntries.push(`<li>${escapeHtml(label)}: ${rawValue}</li>`);
        }
      });

      const countsHtml = countEntries.length
        ? `<ul class="small mb-0 ps-3">${countEntries.join('')}</ul>`
        : '';

      const entries = Array.isArray(task.entries) ? task.entries : [];
      const highlighted = entries.filter((entry) => {
        const entryStatus = (entry.status || '').toString().toLowerCase();
        return ['progress', 'error', 'failed'].includes(entryStatus);
      });

      let entriesHtml = '';
      if (highlighted.length > 0) {
        const limited = highlighted.slice(0, 5);
        const rendered = limited.map((entry) => {
          const entryStatusLabel = resolveStatusLabel(entry.status);
          const mediaId = entry.mediaId ? `#${escapeHtml(entry.mediaId)}` : '';
          const badges = [];
          if (entry.retryScheduled) {
            badges.push(taskRetryScheduledLabel);
          }
          if (entry.notes) {
            badges.push(escapeHtml(entry.notes));
          }
          const badgeText = badges.length ? ` <span class="text-muted">(${badges.join(', ')})</span>` : '';
          return `<li>${mediaId ? `<code>${mediaId}</code> ` : ''}${escapeHtml(entryStatusLabel)}${badgeText}</li>`;
        });
        if (highlighted.length > limited.length) {
          rendered.push(`<li class="text-muted">${escapeHtml(taskHiddenEntriesLabel)}</li>`);
        }
        entriesHtml = `
          <div class="mt-2">
            <strong>${escapeHtml(taskAttentionLabel)}:</strong>
            <ul class="small mb-0 ps-3">${rendered.join('')}</ul>
          </div>
        `;
      }

      const headerLabel = escapeHtml(task.label || task.key || taskLabelDefault);

      return `
        <div class="border rounded-3 bg-body-tertiary p-3">
          <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-2">
            <div class="fw-semibold">${headerLabel}</div>
            <span class="badge bg-${badgeClass}">${escapeHtml(statusLabel)}</span>
          </div>
          ${countsHtml}
          ${entriesHtml}
        </div>
      `;
    });

    localImportTasksEl.innerHTML = `<div class="d-flex flex-column gap-2">${sections.join('')}</div>`;
  }

  function formatLogDetails(details) {
    if (!details || typeof details !== 'object') {
      return '';
    }

    const entries = Object.entries(details)
      .map(([key, value]) => {
        if (value === null || value === undefined || value === '') {
          return null;
        }
        let normalized = value;
        if (typeof normalized === 'object') {
          try {
            normalized = JSON.stringify(normalized);
          } catch (err) {
            normalized = String(normalized);
          }
        }
        return `${escapeHtml(key)}=${escapeHtml(String(normalized))}`;
      })
      .filter(Boolean);

    return entries.join(', ');
  }

  function toggleLogDownloadButton(show = false) {
    if (!logDownloadButton) {
      return;
    }

    if (show) {
      logDownloadButton.classList.remove('d-none');
      if (!logDownloadButton.disabled) {
        logDownloadButton.innerHTML = logDownloadDefaultHtml;
      }
    } else {
      logDownloadButton.classList.add('d-none');
    }
  }

  function normalizeFileName(value) {
    if (value === null || value === undefined) {
      return '';
    }
    if (typeof value === 'string') {
      return value.trim().toLowerCase();
    }
    try {
      return String(value).trim().toLowerCase();
    } catch (err) {
      return '';
    }
  }

  function extractSelectionId(details) {
    if (!details || typeof details !== 'object') {
      return null;
    }
    const candidates = [
      details.selection_id,
      details.selectionId,
      details.selectionID,
      details.selection,
    ];
    for (const candidate of candidates) {
      if (candidate === null || candidate === undefined) {
        continue;
      }
      if (typeof candidate === 'number' && Number.isFinite(candidate)) {
        return candidate;
      }
      if (typeof candidate === 'string') {
        const trimmed = candidate.trim();
        if (!trimmed) {
          continue;
        }
        const parsed = Number.parseInt(trimmed, 10);
        if (!Number.isNaN(parsed)) {
          return parsed;
        }
      } else {
        const parsed = Number.parseInt(candidate, 10);
        if (!Number.isNaN(parsed)) {
          return parsed;
        }
      }
    }
    return null;
  }

  function extractFileTaskIdFromLog(logEntry) {
    if (!logEntry || typeof logEntry !== 'object') {
      return null;
    }
    if (typeof logEntry.fileTaskId === 'string' && logEntry.fileTaskId.trim()) {
      return logEntry.fileTaskId.trim();
    }
    const details = logEntry.details || {};
    const candidates = [details.fileTaskId, details.file_task_id];
    for (const candidate of candidates) {
      if (typeof candidate === 'string' && candidate.trim()) {
        return candidate.trim();
      }
    }
    return null;
  }

  function buildSelectionFileTaskMap(logs = []) {
    selectionFileTaskMap.clear();
    fileNameTaskMap.clear();
    if (!Array.isArray(logs)) {
      return;
    }
    logs.forEach((entry) => {
      if (!entry || typeof entry !== 'object') {
        return;
      }
      const details = entry.details || {};
      const fileTaskId = extractFileTaskIdFromLog(entry);
      if (fileTaskId) {
        const selectionId = extractSelectionId(details);
        if (selectionId !== null && selectionId !== undefined) {
          selectionFileTaskMap.set(selectionId, fileTaskId);
        }
        const nameCandidates = [
          details.basename,
          details.file,
          details.filename,
          details.name,
          details.path,
          details.source,
          details.source_path,
          details.file_path,
        ];
        for (const candidate of nameCandidates) {
          const normalized = normalizeFileName(candidate);
          if (normalized) {
            fileNameTaskMap.set(normalized, fileTaskId);
            break;
          }
        }
      }
    });
  }

  function filterLogsByFileTask(fileTaskId) {
    const source = Array.isArray(allLogsCache) ? allLogsCache : [];
    if (!fileTaskId) {
      return [...source];
    }

    const uniqueById = new Set();
    const uniqueByFallback = new Set();
    const filtered = [];

    source.forEach((entry) => {
      if (extractFileTaskIdFromLog(entry) !== fileTaskId) {
        return;
      }

      const normalizedId = normalizeLogId(entry?.id);
      if (normalizedId !== null) {
        if (uniqueById.has(normalizedId)) {
          return;
        }
        uniqueById.add(normalizedId);
        filtered.push(entry);
        return;
      }

      const fallbackKey = buildLogFallbackKey(entry);
      if (!fallbackKey || uniqueByFallback.has(fallbackKey)) {
        return;
      }

      uniqueByFallback.add(fallbackKey);
      filtered.push(entry);
    });

    return filtered;
  }

  function normalizeLogId(value) {
    if (typeof value === 'number' && Number.isFinite(value)) {
      return value;
    }
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (trimmed.length > 0) {
        const parsed = Number.parseInt(trimmed, 10);
        if (!Number.isNaN(parsed)) {
          return parsed;
        }
      }
    }
    return null;
  }

  function buildLogFallbackKey(entry) {
    if (!entry || typeof entry !== 'object') {
      return '';
    }
    const createdAt = entry.createdAt ? new Date(entry.createdAt).getTime() : 0;
    const event = entry.event || '';
    const status = entry.status || '';
    const message = entry.message || '';
    const details = entry.details ? JSON.stringify(entry.details) : '';
    return `${createdAt}|${event}|${status}|${message}|${details}`;
  }

  function mergeLogs(existing = [], incoming = []) {
    const byId = new Map();
    const byFallbackKey = new Map();

    const addEntry = (entry) => {
      if (!entry || typeof entry !== 'object') {
        return;
      }

      const normalizedId = normalizeLogId(entry.id);
      if (normalizedId !== null) {
        const previous = byId.get(normalizedId);
        const merged = previous ? { ...previous, ...entry, id: normalizedId } : { ...entry, id: normalizedId };
        byId.set(normalizedId, merged);
        return;
      }

      const fallbackKey = buildLogFallbackKey(entry);
      if (!fallbackKey) {
        return;
      }
      const previous = byFallbackKey.get(fallbackKey);
      const merged = previous ? { ...previous, ...entry } : entry;
      byFallbackKey.set(fallbackKey, merged);
    };

    existing.forEach(addEntry);
    incoming.forEach(addEntry);

    const sortedById = Array.from(byId.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([, value]) => value);

    const fallbackEntries = Array.from(byFallbackKey.values())
      .sort((a, b) => {
        const timeA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
        const timeB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
        if (timeA === timeB) {
          return 0;
        }
        return timeA - timeB;
      });

    return [...sortedById, ...fallbackEntries];
  }

  function setLogPaginationLoading(isLoading) {
    if (!logPaginationButton || !logPaginationSpinner) {
      return;
    }
    if (isLoading) {
      logPaginationSpinner.classList.remove('d-none');
      logPaginationButton.disabled = true;
      logPaginationButton.classList.add('disabled');
    } else {
      logPaginationSpinner.classList.add('d-none');
      const hasOlder = Boolean(logPaginationState.hasOlderLogs);
      logPaginationButton.disabled = !hasOlder;
      logPaginationButton.classList.toggle('disabled', !hasOlder);
    }
  }

  function updateLogPaginationControls() {
    if (!logPaginationContainer) {
      return;
    }

    const total = Array.isArray(allLogsCache) ? allLogsCache.length : 0;
    const hasLogs = total > 0;
    const hasOlder = Boolean(logPaginationState.hasOlderLogs);

    if (!hasLogs && !hasOlder) {
      logPaginationContainer.classList.add('d-none');
      if (logPaginationStatusEl) {
        logPaginationStatusEl.textContent = '';
      }
      if (logPaginationButton) {
        logPaginationButton.classList.add('d-none');
        logPaginationButton.disabled = true;
        logPaginationButton.classList.add('disabled');
      }
      if (logPaginationSpinner) {
        logPaginationSpinner.classList.add('d-none');
      }
      return;
    }

    logPaginationContainer.classList.remove('d-none');

    if (logPaginationStatusEl) {
      logPaginationStatusEl.textContent = `{{ _("Showing") }} ${total.toLocaleString()}`;
    }

    if (logPaginationButton) {
      logPaginationButton.classList.toggle('d-none', !hasOlder);
      logPaginationButton.disabled = !hasOlder;
      logPaginationButton.classList.toggle('disabled', !hasOlder);
      if (!hasOlder && logPaginationSpinner) {
        logPaginationSpinner.classList.add('d-none');
      }
    }
  }

  function resolveFileTaskDisplayName(fileTaskId, fallback = '') {
    if (!fileTaskId) {
      return fallback;
    }
    const metadata = fileTaskMetadataMap.get(fileTaskId);
    if (metadata && metadata.fileName) {
      return metadata.fileName;
    }
    const fromLogs = (Array.isArray(allLogsCache) ? allLogsCache : []).find(
      (entry) => extractFileTaskIdFromLog(entry) === fileTaskId,
    );
    if (fromLogs) {
      const details = fromLogs.details || {};
      const nameCandidates = [
        details.basename,
        details.file,
        details.filename,
        details.name,
        details.path,
        details.source,
        details.source_path,
        details.file_path,
      ];
      for (const candidate of nameCandidates) {
        if (typeof candidate === 'string' && candidate.trim()) {
          return candidate;
        }
      }
    }
    return fallback || fileTaskId;
  }

  function updateLogFilterNotice(filterState) {
    if (!logFilterNoticeEl) {
      return;
    }
    if (!filterState || !filterState.fileTaskId) {
      logFilterNoticeEl.classList.add('d-none');
      if (logFilterNoticeTextEl) {
        logFilterNoticeTextEl.textContent = '';
      }
      if (logFilterClearButton) {
        logFilterClearButton.classList.add('d-none');
        logFilterClearButton.disabled = true;
        logFilterClearButton.innerHTML = `<i class="bi bi-x-circle"></i> ${escapeHtml(showAllLogsLabel)}`;
      }
      return;
    }

    const fileDisplayName = filterState.fileName
      || resolveFileTaskDisplayName(filterState.fileTaskId, filterState.fileTaskId);
    const labelHtml = `<span class="fw-semibold">${escapeHtml(logFilterActivePrefix)}:</span> ${escapeHtml(logFilterActiveForLabel)} <code>${escapeHtml(fileDisplayName)}</code>`;
    logFilterNoticeEl.classList.remove('d-none');
    if (logFilterNoticeTextEl) {
      logFilterNoticeTextEl.innerHTML = labelHtml;
    }
    if (logFilterClearButton) {
      logFilterClearButton.classList.remove('d-none');
      logFilterClearButton.disabled = false;
      logFilterClearButton.innerHTML = `<i class="bi bi-x-circle"></i> ${escapeHtml(showAllLogsLabel)}`;
    }
  }

  function clearLogFilter() {
    logFilterState = null;
    updateLogFilterNotice(null);
    renderSessionLogs(allLogsCache);
  }

  function applyLogFilter(filterState) {
    if (!filterState || !filterState.fileTaskId) {
      clearLogFilter();
      return;
    }

    const resolvedName = filterState.fileName
      || resolveFileTaskDisplayName(filterState.fileTaskId, filterState.fileTaskId);

    logFilterState = {
      fileTaskId: filterState.fileTaskId,
      selectionId: filterState.selectionId || null,
      fileName: resolvedName,
    };

    const filteredLogs = filterLogsByFileTask(logFilterState.fileTaskId);
    renderSessionLogs(filteredLogs, { filter: logFilterState });

    if (
      filteredLogs.length === 0
      && typeof showInfoToast === 'function'
    ) {
      showInfoToast(logFilterUnavailableMessage, 4000);
    }
  }

  function resolveFileTaskIdForSelection(selectionId, selectionData = null, fallbackName = '') {
    if (selectionId === null || selectionId === undefined) {
      return null;
    }

    if (selectionFileTaskMap.has(selectionId)) {
      return selectionFileTaskMap.get(selectionId);
    }

    const selection = selectionData || selectionRecords.get(selectionId) || {};
    const candidateTaskIds = [selection.fileTaskId];
    for (const candidate of candidateTaskIds) {
      if (typeof candidate === 'string' && candidate.trim()) {
        selectionFileTaskMap.set(selectionId, candidate.trim());
        return candidate.trim();
      }
    }

    const candidateNames = [];
    if (selection.filename) candidateNames.push(selection.filename);
    if (selection.localFilename) candidateNames.push(selection.localFilename);
    if (selection.localFilePath) candidateNames.push(selection.localFilePath);
    if (fallbackName) candidateNames.push(fallbackName);

    const normalizedCandidates = candidateNames
      .map((name) => normalizeFileName(name))
      .filter((value) => Boolean(value));
    const normalizedCandidateSet = new Set(normalizedCandidates);

    for (const normalized of normalizedCandidates) {
      if (fileNameTaskMap.has(normalized)) {
        const matched = fileNameTaskMap.get(normalized);
        selectionFileTaskMap.set(selectionId, matched);
        return matched;
      }
    }

    const logs = Array.isArray(allLogsCache) ? allLogsCache : [];
    for (const entry of logs) {
      const details = entry?.details || {};
      const detailSelectionId = extractSelectionId(details);
      const entryFileTaskId = extractFileTaskIdFromLog(entry);

      if (detailSelectionId === selectionId && entryFileTaskId) {
        selectionFileTaskMap.set(selectionId, entryFileTaskId);
        return entryFileTaskId;
      }

      if (!entryFileTaskId || normalizedCandidateSet.size === 0) {
        continue;
      }

      const detailNames = [
        details.basename,
        details.file,
        details.filename,
        details.name,
        details.path,
        details.source,
        details.source_path,
        details.file_path,
      ];
      for (const detailName of detailNames) {
        const normalized = normalizeFileName(detailName);
        if (normalized && normalizedCandidateSet.has(normalized)) {
          selectionFileTaskMap.set(selectionId, entryFileTaskId);
          return entryFileTaskId;
        }
      }
    }

    return null;
  }

  function stripLogDetailSuffix(message, detailsText) {
    if (typeof message !== 'string' || !detailsText) {
      return message;
    }

    const marker = ' | details=';
    const markerIndex = message.lastIndexOf(marker);
    if (markerIndex === -1) {
      return message;
    }

    const prefix = message.slice(0, markerIndex);
    return prefix.trimEnd();
  }

  function renderSessionLogs(logs = [], options = {}) {
    if (!logSection || !logBody) {
      return;
    }

    const entries = Array.isArray(logs) ? logs : [];
    currentLogs = [...entries];

    const activeFilter = options && options.filter ? options.filter.fileTaskId : null;
    const filterState = options && options.filter ? options.filter : null;

    logSection.classList.remove('d-none');
    logBody.innerHTML = '';
    toggleLogDownloadButton(true);
    updateLogFilterNotice(filterState);

    if (!entries || entries.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.id = 'local-import-log-empty';
      emptyRow.innerHTML = `<td colspan="5" class="text-center text-muted py-3">${escapeHtml(noLogsMessage)}</td>`;
      logBody.appendChild(emptyRow);
      updateLogPaginationControls();
      return;
    }

    entries.forEach((log) => {
      const row = document.createElement('tr');
      const level = (log.level || '').toUpperCase();
      const badgeClass = getLevelBadgeClass(level);
      const statusText = (log.status || '').toString();
      const statusBadgeClass = getStatusBadgeClass(statusText);
      const detailsText = formatLogDetails(log.details);
      const displayMessage = stripLogDetailSuffix(log.message || '', detailsText);

      const messageHtml = [
        escapeHtml(displayMessage || ''),
        detailsText ? `<div class="text-muted small">${detailsText}</div>` : ''
      ].join('');

      if (activeFilter && extractFileTaskIdFromLog(log) === activeFilter) {
        row.classList.add('table-active');
      }

      row.innerHTML = `
        <td>${escapeHtml(formatDateTime(log.createdAt))}</td>
        <td>${log.event ? `<code>${escapeHtml(log.event)}</code>` : '-'}</td>
        <td>${statusText ? `<span class="badge bg-${statusBadgeClass}">${escapeHtml(statusText)}</span>` : '-'}</td>
        <td>${level ? `<span class="badge bg-${badgeClass}">${escapeHtml(level)}</span>` : '-'}</td>
        <td>${messageHtml}</td>
      `;

      logBody.appendChild(row);
    });

    updateLogPaginationControls();
  }

  function renderFileTasks(items = []) {
    if (!fileProgressSection || !fileProgressBody) {
      return;
    }

    fileProgressSection.classList.remove('d-none');
    fileProgressBody.innerHTML = '';
    fileTaskMetadataMap.clear();
    fileNameTaskMap.clear();

    const allItems = Array.isArray(items) ? items : [];

    if (allItems.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="5" class="text-center text-muted py-3">${escapeHtml(noFileTasksMessage)}</td>`;
      fileProgressBody.appendChild(emptyRow);
      return;
    }

    const registerFileTaskMetadata = (item) => {
      if (!item || !item.fileTaskId) {
        return;
      }

      fileTaskMetadataMap.set(item.fileTaskId, {
        fileName: item.fileName || item.fileTaskId,
        state: item.state,
        updatedAt: item.updatedAt,
      });

      const normalizedName = normalizeFileName(item.fileName || item.fileTaskId);
      if (normalizedName) {
        fileNameTaskMap.set(normalizedName, item.fileTaskId);
      }
    };

    allItems.forEach(registerFileTaskMetadata);

    const itemsToDisplay = allItems.slice(0, FILE_PROGRESS_MAX_ITEMS);

    itemsToDisplay.forEach((item) => {
      const row = document.createElement('tr');
      const state = (item.state || '').toString().toLowerCase();
      const badgeClass = getFileTaskBadgeClass(state);
      const stateLabel = fileTaskStateLabels[state] || item.state || unknownLabel;
      const rawStatus = (item.status || '').toString();
      const progressValue = item.progressStep;
      const stepLabel = typeof progressValue === 'number' ? (progressStepLabels[progressValue] || null) : null;
      const stepText = typeof progressValue === 'number'
        ? `${progressValue}${stepLabel ? ` (${escapeHtml(stepLabel)})` : ''}`
        : '-';
      const updatedAt = item.updatedAt ? escapeHtml(formatDateTime(item.updatedAt)) : '-';
      const messageParts = [];
      if (item.message) {
        messageParts.push(escapeHtml(item.message));
      }
      if (item.notes) {
        messageParts.push(`<span class="text-muted small">${escapeHtml(item.notes)}</span>`);
      }
      if (item.error) {
        messageParts.push(`<span class="text-danger small">${escapeHtml(item.error)}</span>`);
      }
      if (item.event) {
        messageParts.push(`<span class="text-muted small">${escapeHtml(item.event)}</span>`);
      }
      if (!messageParts.length) {
        messageParts.push('-');
      }

      const rawStatusHtml = rawStatus
        ? `<div class="text-muted small">${escapeHtml(rawStatus)}</div>`
        : '';

      row.innerHTML = `
        <td>${escapeHtml(item.fileName || item.fileTaskId || '-')}
          ${item.fileTaskId ? `<div class="text-muted small">${escapeHtml(item.fileTaskId)}</div>` : ''}
        </td>
        <td>
          <span class="badge bg-${badgeClass}">${escapeHtml(stateLabel)}</span>
          ${rawStatusHtml}
        </td>
        <td>${stepText}</td>
        <td>${updatedAt}</td>
        <td>${messageParts.join('<br>')}</td>
      `;

      fileProgressBody.appendChild(row);
    });

    if (allItems.length > itemsToDisplay.length) {
      const hiddenCount = allItems.length - itemsToDisplay.length;
      const infoRow = document.createElement('tr');
      const hiddenLabel = `${escapeHtml(taskHiddenEntriesLabel)} (${hiddenCount.toLocaleString()})`;
      infoRow.innerHTML = `<td colspan="5" class="text-center text-muted small">${hiddenLabel}</td>`;
      fileProgressBody.appendChild(infoRow);
    }
  }

  const selectionRecords = new Map();
  const selectionFileTaskMap = new Map();
  const fileTaskMetadataMap = new Map();
  const fileNameTaskMap = new Map();
  const logPaginationState = {
    oldestLoadedId: null,
    newestLoadedId: null,
    nextCursor: null,
    hasOlderLogs: false,
  };
  let allLogsCache = [];
  let currentLogs = [];
  let logFilterState = null;
  let isFetchingLogs = false;
  let paginationClient;
  let isLocalImport = false;
  let latestStatus = 'unknown';
  let isRefreshing = false;
  let currentCounts = {};
  let displayedSelectionCount = 0;
  let selectionRefreshStaging = null;

  toggleLogDownloadButton(false);

  function resetLogPaginationState() {
    logPaginationState.oldestLoadedId = null;
    logPaginationState.newestLoadedId = null;
    logPaginationState.nextCursor = null;
    logPaginationState.hasOlderLogs = false;
  }

  resetLogPaginationState();

  function formatDateTime(isoString) {
    if (!isoString) return '-';
    const helper = window.appTime;
    if (helper && typeof helper.formatDateTime === 'function') {
      const formatted = helper.formatDateTime(isoString);
      if (formatted) {
        return formatted;
      }
    }
    try {
      const date = new Date(isoString);
      return Number.isNaN(date.getTime()) ? '-' : date.toLocaleString();
    } catch (e) {
      return isoString;
    }
  }

  function formatCounts(counts) {
    if (!counts || Object.keys(counts).length === 0) {
      return '';
    }
    return Object.entries(counts)
      .map(([status, count]) => `${selectionStatusLabels[status] || status}: ${count}`)
      .join(', ');
  }

  function totalFromCounts(counts = {}) {
    return Object.values(counts).reduce((total, value) => total + (Number(value) || 0), 0);
  }

  function duplicateCount(counts = {}) {
    return Number(counts?.dup || 0);
  }

  function hasOnlyDuplicates(counts = {}) {
    let dupTotal = 0;
    let otherTotal = 0;

    Object.entries(counts).forEach(([status, count]) => {
      const numericCount = Number(count) || 0;
      if (status === 'dup') {
        dupTotal += numericCount;
      } else if (numericCount > 0) {
        otherTotal += numericCount;
      }
    });

    return dupTotal > 0 && otherTotal === 0;
  }

  function determineDisplayStatus(sessionData) {
    const baseStatus = sessionData?.status || 'pending';
    if (['processing', 'importing', 'error', 'failed'].includes(baseStatus) && hasOnlyDuplicates(sessionData?.counts || {})) {
      return 'imported';
    }
    return baseStatus;
  }

  function deriveSelectedCount(sessionData) {
    const countsTotal = totalFromCounts(sessionData?.counts || {});
    if (countsTotal > 0) {
      return countsTotal;
    }
    const selected = sessionData?.selectedCount;
    if (typeof selected === 'number' && selected > 0) {
      return selected;
    }
    return selected || 0;
  }

  function createSelectionRow(selection) {
    const tr = document.createElement('tr');
    const displayName = selection.filename || selection.googleMediaId || 'N/A';
    const safeDisplayName = escapeHtml(displayName);
    const canDisplayLink = selection.mediaId && ['imported', 'dup'].includes(selection.status);
    const fileCellContent = canDisplayLink
      ? `<a href="/photo-view/media/${selection.mediaId}" class="text-decoration-none" target="_blank">${safeDisplayName}</a>`
      : safeDisplayName;
    const errorMessageHtml = selection.error
      ? `<div class="text-danger small">${escapeHtml(selection.error)}</div>`
      : '<span class="text-muted small">-</span>';
    const errorLinkHtml = selection.errorDetailsUrl
      ? `<div><a href="${escapeHtml(selection.errorDetailsUrl)}" class="small link-danger link-offset-2">${escapeHtml(viewErrorDetailsLabel)}</a></div>`
      : '';
    const logLinkHtml = (isLocalImport && selection.id)
      ? `<button type="button" class="btn btn-link btn-sm selection-log-link p-0" data-selection-id="${selection.id}" data-file-display="${safeDisplayName}">
          <i class="bi bi-journal-text"></i> ${escapeHtml(viewFileLogsLabel)}
        </button>`
      : '<span class="text-muted small">-</span>';
    tr.innerHTML = `
      <td>${fileCellContent}</td>
      <td>
        <span class="badge bg-${getStatusBadgeClass(selection.status)}">
          ${selectionStatusLabels[selection.status] || selection.status}
        </span>
      </td>
      <td>${selection.attempts}</td>
      <td>${errorMessageHtml}${errorLinkHtml}</td>
      <td>${logLinkHtml}</td>
    `;
    return tr;
  }

  function updateSelectionPagination(meta = {}) {
    if (!selectionPaginationEl || !selectionPaginationButton || !selectionPaginationStatusEl) {
      return;
    }

    const total = typeof meta.total === 'number' ? meta.total : meta.totalCount;
    const hasNext = Boolean(meta.hasNext);
    const hasItems = displayedSelectionCount > 0;

    if (!hasItems && !hasNext) {
      selectionPaginationEl.classList.add('d-none');
      selectionPaginationStatusEl.textContent = '';
      return;
    }

    selectionPaginationEl.classList.remove('d-none');

    if (typeof total === 'number' && !Number.isNaN(total) && total >= 0) {
      const formattedCurrent = displayedSelectionCount.toLocaleString();
      const formattedTotal = total.toLocaleString();
      selectionPaginationStatusEl.textContent = `{{ _("Showing") }} ${formattedCurrent} / ${formattedTotal}`;
    } else {
      selectionPaginationStatusEl.textContent = `{{ _("Showing") }} ${displayedSelectionCount.toLocaleString()}`;
    }

    selectionPaginationButton.disabled = !hasNext;
    selectionPaginationButton.classList.toggle('disabled', !hasNext);
    selectionPaginationButton.classList.toggle('d-none', !hasNext);
    if (!hasNext && selectionPaginationSpinner) {
      selectionPaginationSpinner.classList.add('d-none');
    }
  }

  function setSelectionPaginationLoading(isLoading) {
    if (!selectionPaginationButton || !selectionPaginationSpinner) {
      return;
    }
    if (isLoading) {
      selectionPaginationSpinner.classList.remove('d-none');
      selectionPaginationButton.disabled = true;
      selectionPaginationButton.classList.add('disabled');
    } else {
      selectionPaginationSpinner.classList.add('d-none');
    }
  }

  function buildEmptyMessage(sessionStatus) {
    if (sessionStatus === 'processing') {
      return '<i class="bi bi-clock"></i> Celery処理待ち中...';
    }
    if (sessionStatus === 'ready') {
      return '<i class="bi bi-info-circle"></i> 対象ファイルがありません';
    }
    if (sessionStatus === 'imported') {
      return '<i class="bi bi-check-circle"></i> 処理完了（対象ファイル: 0件）';
    }
    if (sessionStatus === 'error') {
      return '<i class="bi bi-exclamation-triangle text-danger"></i> 処理エラー';
    }
    return '<i class="bi bi-info-circle"></i> 対象ファイルがありません';
  }

  function updateCountsDisplay(counts, sessionStatus) {
    if (counts && Object.keys(counts).length > 0) {
      if (hasOnlyDuplicates(counts)) {
        const dupTotal = duplicateCount(counts);
        const duplicateLabel = selectionStatusLabels.dup || 'Duplicate';
        countsEl.textContent = `${duplicateLabel}: ${dupTotal}`;
      } else {
        countsEl.textContent = formatCounts(counts);
      }
      return;
    }

    if (sessionStatus === 'processing') {
      countsEl.textContent = 'ステータス: 処理待ち';
    } else if (sessionStatus === 'ready') {
      countsEl.textContent = '選択されたファイル: 0件';
    } else if (sessionStatus === 'imported') {
      countsEl.textContent = '処理完了: 0件';
    } else if (sessionStatus === 'error') {
      countsEl.textContent = 'ステータス: エラー';
    } else {
      countsEl.textContent = '選択されたファイル: 0件';
    }
  }

  function updateImportButtonState(sessionData) {
    if (!sessionData) return;
    if (sessionData.isLocalImport) {
      importBtn.style.display = 'none';
      importBtn.disabled = true;
      importBtn.classList.add('disabled');
      importBtn.setAttribute('aria-disabled', 'true');
      return;
    }

    importBtn.style.display = '';
    const canImport = sessionData.status === 'ready';
    importBtn.disabled = !canImport;
    importBtn.classList.toggle('disabled', !canImport);
    importBtn.setAttribute('aria-disabled', (!canImport).toString());
  }

  function updateLocalImportControls(sessionData) {
    if (!stopLocalImportBtn || !localImportStatusEl) {
      return;
    }

    stopLocalImportBtn.classList.add('d-none');
    stopLocalImportBtn.disabled = true;
    stopLocalImportBtn.setAttribute('aria-disabled', 'true');
    localImportStatusEl.classList.add('d-none');
    localImportStatusEl.classList.remove('text-warning', 'text-danger', 'text-success');
    localImportStatusEl.classList.add('text-muted');
    localImportStatusEl.textContent = '';

    if (!sessionData || !sessionData.isLocalImport) {
      return;
    }

    const cancellableStatuses = ['expanding', 'processing', 'importing', 'enqueued'];
    const stats = sessionData.stats || {};
    const cancelRequested = Boolean(stats.cancel_requested);
    const displayStatus = sessionData.status;

    localImportStatusEl.classList.remove('d-none');

    if (displayStatus === 'canceled') {
      localImportStatusEl.textContent = localImportCanceledMessage;
      localImportStatusEl.classList.remove('text-muted');
      localImportStatusEl.classList.add('text-danger');
      return;
    }

    if (cancelRequested) {
      localImportStatusEl.textContent = localImportCancelingMessage;
      localImportStatusEl.classList.remove('text-muted');
      localImportStatusEl.classList.add('text-warning');
      return;
    }

    if (cancellableStatuses.includes(displayStatus)) {
      localImportStatusEl.textContent = localImportRunningMessage;
      stopLocalImportBtn.classList.remove('d-none');
      stopLocalImportBtn.disabled = false;
      stopLocalImportBtn.setAttribute('aria-disabled', 'false');
      return;
    }

    localImportStatusEl.textContent = '{{ _("Local import session runs automatically.") }}';
  }

  function buildSelectionQueryParams() {
    const params = {};

    if (selectionFilterSearchInput) {
      const value = selectionFilterSearchInput.value.trim();
      if (value.length > 0) {
        params.search = value;
      }
    }

    if (selectionFilterStatusSelect) {
      const statusValue = selectionFilterStatusSelect.value;
      if (statusValue) {
        params.status = statusValue;
      }
    }

    return params;
  }

  function updateSessionInfo(sessionData) {
    if (!sessionData) {
      return;
    }

    if (sessionTitleEl) {
      sessionTitleEl.textContent = sessionData.isLocalImport
        ? '{{ _("Local Import Session") }}'
        : '{{ _("Session Details") }}';
    }

    if (sessionSubtitleEl) {
      const subtitleParts = [];
      if (sessionData.sessionId) {
        subtitleParts.push(sessionData.sessionId);
      }
      if (!sessionData.isLocalImport && sessionData.accountEmail) {
        subtitleParts.push(sessionData.accountEmail);
      }
      sessionSubtitleEl.textContent = subtitleParts.join(' • ');
      sessionSubtitleEl.classList.toggle('d-none', subtitleParts.length === 0);
    }

    const stats = sessionData.stats || {};
    const accountLabel = sessionData.isLocalImport
      ? '{{ _("Local Import") }}'
      : (sessionData.accountEmail || '-');
    const selectedCount = deriveSelectedCount(sessionData);
    const countsSummary = formatCounts(sessionData.counts) || '-';
    const createdAt = formatDateTime(sessionData.createdAt);
    const lastProgress = formatDateTime(sessionData.lastProgressAt);
    const statusLabel = sessionStatusLabels[sessionData.status] || sessionData.status || '-';
    const statusBadge = `<span class="badge bg-${getSessionBadgeClass(sessionData.status)}">${statusLabel}</span>`;

    const infoParts = [];
    infoParts.push(`<div><strong>{{ _("Status") }}:</strong> ${statusBadge}</div>`);

    if (sessionData.isLocalImport) {
      const stageValue = stats.stage;
      if (typeof stageValue === 'string' && stageValue.trim().length > 0) {
        const normalizedStage = stageValue.trim().toLowerCase();
        const stageLabel = sessionStageLabels[normalizedStage] || sessionStatusLabels[normalizedStage] || stageValue;
        infoParts.push(`<div><strong>{{ _("Current Stage") }}:</strong> ${escapeHtml(stageLabel)}</div>`);
      }
    }

    infoParts.push(`<div><strong>{{ _("Target Account") }}:</strong> ${accountLabel}</div>`);
    infoParts.push(`<div><strong>{{ _("Selected Files") }}:</strong> ${selectedCount}</div>`);
    infoParts.push(`<div><strong>{{ _("File Status") }}:</strong> ${countsSummary}</div>`);
    infoParts.push(`<div><strong>{{ _("Created At") }}:</strong> ${createdAt}</div>`);
    infoParts.push(`<div><strong>{{ _("Last Progress") }}:</strong> ${lastProgress}</div>`);

    if (sessionData.isLocalImport) {
      if (sessionData.status === 'canceled') {
        infoParts.push(`<div class="mt-2 text-muted"><i class="bi bi-x-circle"></i> {{ _("Local import was canceled.") }}</div>`);
      } else if (stats.cancel_requested) {
        infoParts.push(`<div class="mt-2 text-warning"><i class="bi bi-hourglass-split"></i> {{ _("Canceling local import...") }}</div>`);
      } else {
        infoParts.push(`<div class="mt-2 text-muted"><i class="bi bi-info-circle"></i> {{ _("Local Import Session. Import runs automatically.") }}</div>`);
      }
    } else if (sessionData.status !== 'ready') {
      infoParts.push(`<div class="mt-2 text-warning"><i class="bi bi-exclamation-triangle"></i> {{ _("Import can only be started when the session status is ready.") }}</div>`);
    }

    sessionInfoEl.innerHTML = infoParts.join('');
    renderLocalImportTasks(stats);
    updateLocalImportControls(sessionData);
  }

  async function withBusy(btn, fn) {
    const originalHtml = btn.innerHTML;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> {{ _("Working...") }}';
    btn.disabled = true;
    btn.setAttribute('aria-busy', 'true');
    try {
      return await fn();
    } finally {
      btn.innerHTML = originalHtml;
      btn.disabled = false;
      btn.removeAttribute('aria-busy');
    }
  }

  async function fetchSessionStatus() {
    try {
      const resp = await window.apiClient.get(`/api/picker/session/${encodeURIComponent(pickerSessionId)}`);
      if (resp.status === 404) {
        window.location.href = '/photo-view/session';
        return null;
      }
      if (resp.status === 401 || resp.status === 302) {
        window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname + window.location.search);
        return null;
      }
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}`);
      }

      const data = await resp.json();
      data.counts = data.counts || {};
      data.status = determineDisplayStatus(data);
      isLocalImport = Boolean(data.isLocalImport);
      updateImportButtonState(data);
      updateSessionInfo(data);
      return data;
    } catch (error) {
      console.warn('Failed to fetch session status:', error);
      return null;
    }
  }

  async function fetchSessionLogs(options = {}) {
    if (!pickerSessionId) {
      allLogsCache = [];
      resetLogPaginationState();
      renderSessionLogs([]);
      return;
    }

    const {
      mode = logPaginationState.newestLoadedId !== null ? 'after' : 'initial',
      cursor = null,
      afterId = null,
      appendOlder = false,
      resetExisting = false,
      limit = LOG_PAGE_SIZE,
      fileTaskId = null,
    } = options || {};

    if (isFetchingLogs) {
      return;
    }

    const cursorNumber = typeof cursor === 'number' ? cursor : Number.parseInt(cursor, 10);
    const afterNumber = typeof afterId === 'number' ? afterId : Number.parseInt(afterId, 10);
    const previousNewestId = typeof logPaginationState.newestLoadedId === 'number'
      ? logPaginationState.newestLoadedId
      : null;
    const effectiveLimit = Number.isFinite(limit)
      ? Math.max(1, Math.min(limit, LOG_PAGE_MAX))
      : LOG_PAGE_SIZE;

    const params = new URLSearchParams();
    params.set('limit', effectiveLimit);
    if (Number.isFinite(cursorNumber) && cursorNumber > 0) {
      params.set('cursor', cursorNumber);
    }
    if (Number.isFinite(afterNumber) && afterNumber >= 0) {
      params.set('after', afterNumber);
    }
    if (fileTaskId) {
      params.set('file_task_id', fileTaskId);
    }

    if (appendOlder) {
      setLogPaginationLoading(true);
    }

    isFetchingLogs = true;

    try {
      const query = params.toString();
      const url = `/api/picker/session/${encodeURIComponent(pickerSessionId)}/logs${query ? `?${query}` : ''}`;
      const resp = await window.apiClient.get(url);
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}`);
      }

      const payload = await resp.json().catch(() => ({}));
      const logs = Array.isArray(payload.logs) ? payload.logs : [];
      const hasNext = Boolean(payload.hasNext);
      const nextCursor = typeof payload.nextCursor === 'number' ? payload.nextCursor : null;
      const payloadOldestId = typeof payload.oldestLogId === 'number'
        ? payload.oldestLogId
        : (logs.length > 0 ? logs[0].id : null);
      const payloadNewestId = typeof payload.newestLogId === 'number'
        ? payload.newestLogId
        : (logs.length > 0 ? logs[logs.length - 1].id : null);

      let logsToMerge = logs;

      if (!fileTaskId && mode === 'after' && Number.isFinite(previousNewestId)) {
        logsToMerge = logs.filter((entry) => {
          const normalizedId = normalizeLogId(entry?.id);
          if (normalizedId === null) {
            return true;
          }
          return normalizedId > previousNewestId;
        });
      }

      const oldestId = normalizeLogId(payloadOldestId);
      const newestId = normalizeLogId(payloadNewestId);

      if (resetExisting && !fileTaskId) {
        allLogsCache = [];
        resetLogPaginationState();
      }

      if (logsToMerge.length > 0) {
        allLogsCache = mergeLogs(allLogsCache, logsToMerge);
      } else if (resetExisting && !fileTaskId) {
        allLogsCache = [];
      }

      if (!fileTaskId) {
        if (mode === 'older' || mode === 'initial') {
          if (oldestId !== null) {
            if (logPaginationState.oldestLoadedId === null || oldestId < logPaginationState.oldestLoadedId) {
              logPaginationState.oldestLoadedId = oldestId;
            }
          }
          logPaginationState.hasOlderLogs = hasNext;
          logPaginationState.nextCursor = hasNext
            ? (typeof nextCursor === 'number' ? nextCursor : oldestId)
            : null;
        }

        if (logsToMerge.length > 0 && newestId !== null) {
          if (logPaginationState.newestLoadedId === null || newestId > logPaginationState.newestLoadedId) {
            logPaginationState.newestLoadedId = newestId;
          }
        }
      }

      buildSelectionFileTaskMap(allLogsCache);

      if (logFilterState && logFilterState.fileTaskId) {
        logFilterState = {
          ...logFilterState,
          fileName: resolveFileTaskDisplayName(
            logFilterState.fileTaskId,
            logFilterState.fileName || logFilterState.fileTaskId,
          ),
        };
      }

      const effectiveLogs = logFilterState
        ? filterLogsByFileTask(logFilterState.fileTaskId)
        : allLogsCache;

      if (logFilterState) {
        renderSessionLogs(effectiveLogs, { filter: logFilterState });
      } else {
        renderSessionLogs(effectiveLogs);
      }
    } catch (error) {
      console.warn('Failed to fetch session logs:', error);
      if (!fileTaskId && appendOlder) {
        logPaginationState.hasOlderLogs = false;
        logPaginationState.nextCursor = null;
        updateLogPaginationControls();
      }
    } finally {
      if (appendOlder) {
        setLogPaginationLoading(false);
      }
      isFetchingLogs = false;
    }
  }

  async function fetchFileTasks() {
    if (!pickerSessionId || !isLocalImport) {
      if (fileProgressSection) {
        fileProgressSection.classList.add('d-none');
      }
      return;
    }

    if (!fileProgressSection || !fileProgressBody) {
      return;
    }

    try {
      const resp = await window.apiClient.get(`/api/picker/session/${encodeURIComponent(pickerSessionId)}/file-tasks`);
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}`);
      }

      const payload = await resp.json().catch(() => ({}));
      const items = Array.isArray(payload.items) ? payload.items : [];
      renderFileTasks(items);
    } catch (error) {
      console.warn('Failed to fetch file task summaries:', error);
    }
  }

  async function stopLocalImportSession() {
    if (!pickerSessionId || !stopLocalImportBtn) {
      return;
    }

    await withBusy(stopLocalImportBtn, async () => {
      try {
        const resp = await window.apiClient.post(`/api/sync/local-import/${encodeURIComponent(pickerSessionId)}/stop`);

        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          console.error('Failed to stop local import:', resp.status, text);
          statusEl.textContent = localImportStopFailedMessage;
          showErrorToast(localImportStopFailedMessage);
          return;
        }

        const payload = await resp.json().catch(() => ({}));
        const message = (payload && payload.message) ? payload.message : localImportCanceledMessage;
        statusEl.textContent = message;
        showInfoToast(message, 4000);
        await fetchSessionStatus();
        await refreshSelections();
      } catch (error) {
        console.error('Stop local import failed:', error);
        statusEl.textContent = localImportStopFailedMessage;
        showErrorToast(localImportStopFailedMessage);
      }
    });
  }

  async function refreshSelections(options = {}) {
    const { forceReset = false, showSearchSpinner = false } = options || {};
    if (isRefreshing) {
      return;
    }
    if (showSearchSpinner) {
      setSelectionFilterSearchBusy(true);
    }
    isRefreshing = true;
    setSelectionSearchLoading(showSearchSpinner);
    try {
      const sessionData = await fetchSessionStatus();
      latestStatus = sessionData?.status || latestStatus;
      currentCounts = sessionData?.counts || currentCounts || {};
      updateCountsDisplay(currentCounts, latestStatus);

      if (forceReset) {
        await fetchSessionLogs({ mode: 'initial', resetExisting: true });
      } else if (logPaginationState.newestLoadedId !== null) {
        await fetchSessionLogs({ mode: 'after', afterId: logPaginationState.newestLoadedId });
      } else {
        await fetchSessionLogs({ mode: 'initial', resetExisting: true });
      }
      await fetchFileTasks();

      if (!paginationClient) {
        paginationClient = new PaginationClient({
          baseUrl: `/api/picker/session/${encodeURIComponent(pickerSessionId)}/selections`,
          pageSize: 200,
          autoLoad: false,
          onItemsLoaded: (items, meta) => {
            const isStaging = Boolean(selectionRefreshStaging);

            if (meta.currentPage === 1) {
              if (isStaging) {
                selectionRefreshStaging.rows = [];
                selectionRefreshStaging.displayedCount = 0;
                selectionRefreshStaging.lastMeta = null;
              } else {
                selectionBody.innerHTML = '';
                displayedSelectionCount = 0;
              }
              selectionRecords.clear();
            }

            if (items.length === 0 && meta.currentPage === 1) {
              const tr = document.createElement('tr');
              tr.innerHTML = `
                <td colspan="5" class="text-center text-muted py-4">
                  ${buildEmptyMessage(latestStatus)}
                </td>
              `;

              if (isStaging) {
                selectionRefreshStaging.rows.push(tr);
                selectionRefreshStaging.displayedCount = 0;
                selectionRefreshStaging.lastMeta = { hasNext: false, total: 0, totalCount: 0 };
                return;
              }

              selectionBody.appendChild(tr);
              updateSelectionPagination({ hasNext: false, total: 0, totalCount: 0 });
              return;
            }

            if (items.length > 0) {
              items.forEach((selection) => {
                if (selection && typeof selection.id === 'number') {
                  selectionRecords.set(selection.id, selection);
                }
              });

              const newRows = items.map(selection => createSelectionRow(selection));

              if (isStaging) {
                newRows.forEach(row => selectionRefreshStaging.rows.push(row));
                selectionRefreshStaging.displayedCount += items.length;
                selectionRefreshStaging.lastMeta = {
                  hasNext: meta.hasNext,
                  total: meta.total,
                  totalCount: meta.total,
                };
              } else {
                newRows.forEach(row => selectionBody.appendChild(row));
                displayedSelectionCount += items.length;
                updateSelectionPagination({
                  hasNext: meta.hasNext,
                  total: meta.total,
                  totalCount: meta.total,
                });
              }
              return;
            }

            if (isStaging) {
              selectionRefreshStaging.lastMeta = {
                hasNext: meta.hasNext,
                total: meta.total,
                totalCount: meta.total,
              };
            } else {
              updateSelectionPagination({
                hasNext: meta.hasNext,
                total: meta.total,
                totalCount: meta.total,
              });
            }
          },
          onError: (error) => {
            console.error('Selection loading error:', error);
          },
          onLoadingStateChange: (state) => {
            setSelectionPaginationLoading(state);
          },
        });
        if (selectionPaginationButton) {
          selectionPaginationButton.addEventListener('click', () => {
            if (paginationClient) {
              paginationClient.loadNext();
            }
          });
        }
      }

      if (forceReset && paginationClient) {
        paginationClient.reset();
        selectionRefreshStaging = null;
        displayedSelectionCount = 0;
        selectionRecords.clear();
      }

      if (paginationClient) {
        paginationClient.defaultParams = buildSelectionQueryParams();
      }

      const loadedPagesBeforeRefresh = paginationClient
        ? Math.max(0, paginationClient.currentPage - 1)
        : 0;

      const shouldStageRows = loadedPagesBeforeRefresh > 1;
      if (shouldStageRows) {
        selectionRefreshStaging = {
          rows: [],
          displayedCount: 0,
          lastMeta: null,
        };
      } else {
        selectionRefreshStaging = null;
      }

      await paginationClient.loadFirst();

      if (paginationClient && loadedPagesBeforeRefresh > 1) {
        const additionalPagesToReload = loadedPagesBeforeRefresh - 1;
        for (let pageIndex = 0; pageIndex < additionalPagesToReload; pageIndex += 1) {
          if (!paginationClient.hasNext) {
            break;
          }
          // 既に読み込んでいるページ数を維持するため、順次再取得する
          // setIntervalによる定期リフレッシュ時に「さらに読み込む」で追加表示した行が
          // 消えてしまう問題を防ぐ。
          // eslint-disable-next-line no-await-in-loop
          await paginationClient.loadNext();
        }
      }

      if (selectionRefreshStaging) {
        const { rows, displayedCount, lastMeta } = selectionRefreshStaging;
        selectionBody.innerHTML = '';

        if (rows.length === 0) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td colspan="5" class="text-center text-muted py-4">
              ${buildEmptyMessage(latestStatus)}
            </td>
          `;
          selectionBody.appendChild(tr);
          displayedSelectionCount = 0;
          updateSelectionPagination({ hasNext: false, total: 0, totalCount: 0 });
        } else {
          rows.forEach(row => selectionBody.appendChild(row));
          displayedSelectionCount = displayedCount;
          const fallbackTotal = paginationClient?.items?.length || displayedCount;
          updateSelectionPagination(lastMeta || {
            hasNext: paginationClient?.hasNext || false,
            total: fallbackTotal,
            totalCount: fallbackTotal,
          });
        }

        selectionRefreshStaging = null;
      }
    } catch (err) {
      console.error(err);
    } finally {
      isRefreshing = false;
      setSelectionSearchLoading(false);
      if (showSearchSpinner) {
        setSelectionFilterSearchBusy(false);
      }
    }
  }

  if (selectionFilterForm) {
    selectionFilterForm.addEventListener('submit', (event) => {
      event.preventDefault();
      syncSessionFiltersToHash();
      const submitter = event.submitter || document.activeElement;
      const triggeredBySearchButton = Boolean(selectionFilterSearchBtn && submitter === selectionFilterSearchBtn);
      const triggeredByInput = Boolean(selectionFilterSearchInput && submitter === selectionFilterSearchInput);
      const shouldShowSpinner = triggeredBySearchButton || triggeredByInput;
      refreshSelections({ forceReset: true, showSearchSpinner: shouldShowSpinner });
    });
  }

  // 検索ボタンクリック時に検索実行
  if (selectionFilterSearchBtn) {
    selectionFilterSearchBtn.addEventListener('click', (event) => {
      event.preventDefault();
      syncSessionFiltersToHash();
      refreshSelections({ forceReset: true, showSearchSpinner: true });
    });
  }

  if (selectionFilterStatusSelect) {
    selectionFilterStatusSelect.addEventListener('change', () => {
      syncSessionFiltersToHash();
      refreshSelections({ forceReset: true });
    });
  }

  // 自動検索（input変更時）は無効化
  // if (selectionFilterSearchInput) {
  //   selectionFilterSearchInput.addEventListener('input', () => {
  //     if (selectionFilterSearchDebounce) {
  //       clearTimeout(selectionFilterSearchDebounce);
  //     }
  //     selectionFilterSearchDebounce = setTimeout(() => {
  //       syncSessionFiltersToHash();
  //       refreshSelections({ forceReset: true });
  //     }, 300);
  //   });
  // }

  if (selectionFilterResetButton) {
    selectionFilterResetButton.addEventListener('click', () => {
      if (selectionFilterSearchInput) {
        selectionFilterSearchInput.value = '';
      }
      if (selectionFilterStatusSelect) {
        selectionFilterStatusSelect.value = '';
      }
      syncSessionFiltersToHash();
      refreshSelections({ forceReset: true });
    });
  }

  if (selectionBody) {
    selectionBody.addEventListener('click', (event) => {
      const trigger = event.target.closest('.selection-log-link');
      if (!trigger) {
        return;
      }

      event.preventDefault();

      if (!isLocalImport) {
        return;
      }

      const selectionIdValue = trigger.getAttribute('data-selection-id');
      const selectionId = Number.parseInt(selectionIdValue || '', 10);
      const fallbackName = trigger.getAttribute('data-file-display') || '';

      if (!Number.isFinite(selectionId)) {
        if (typeof showInfoToast === 'function') {
          showInfoToast(logFilterUnavailableMessage, 4000);
        }
        return;
      }

      const selectionData = selectionRecords.get(selectionId) || null;
      const fileTaskId = resolveFileTaskIdForSelection(selectionId, selectionData, fallbackName);

      if (!fileTaskId) {
        if (typeof showInfoToast === 'function') {
          showInfoToast(logFilterUnavailableMessage, 4000);
        }
        return;
      }

      const displayName = selectionData?.filename
        || fallbackName
        || resolveFileTaskDisplayName(fileTaskId, fileTaskId);
      applyLogFilter({ fileTaskId, selectionId, fileName: displayName });

      if (logSection && typeof logSection.scrollIntoView === 'function') {
        logSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    });
  }

  if (logPaginationButton) {
    logPaginationButton.addEventListener('click', () => {
      if (!logPaginationState.hasOlderLogs) {
        return;
      }

      const nextCursor = logPaginationState.nextCursor;
      const cursorValue = typeof nextCursor === 'number' ? nextCursor : Number.parseInt(nextCursor, 10);
      if (!Number.isFinite(cursorValue) || cursorValue <= 0) {
        return;
      }

      fetchSessionLogs({
        mode: 'older',
        cursor: cursorValue,
        appendOlder: true,
      });
    });
  }

  if (logFilterClearButton) {
    logFilterClearButton.addEventListener('click', () => {
      clearLogFilter();
      if (logSection && typeof logSection.scrollIntoView === 'function') {
        logSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    });
  }

  if (logDownloadButton) {
    logDownloadButton.addEventListener('click', async () => {
      if (!pickerSessionId) {
        return;
      }

      logDownloadButton.disabled = true;
      logDownloadButton.innerHTML = logDownloadLoadingHtml;

      try {
        const resp = await window.apiClient.get(`/api/picker/session/${encodeURIComponent(pickerSessionId)}/logs/download`);
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}`);
        }

        const blob = await resp.blob();
        let filename = 'session-logs.zip';
        const disposition = resp.headers.get('Content-Disposition') || '';
        const encodedMatch = disposition.match(/filename\*=UTF-8''([^;]+)/);
        const simpleMatch = disposition.match(/filename="?([^";]+)"?/);

        if (encodedMatch && encodedMatch[1]) {
          try {
            filename = decodeURIComponent(encodedMatch[1]);
          } catch (err) {
            filename = encodedMatch[1];
          }
        } else if (simpleMatch && simpleMatch[1]) {
          filename = simpleMatch[1];
        }

        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }, 0);
      } catch (error) {
        console.error('Failed to download logs:', error);
        if (typeof showErrorToast === 'function') {
          showErrorToast(logDownloadFailedMessage);
        }
      } finally {
        logDownloadButton.innerHTML = logDownloadDefaultHtml;
        logDownloadButton.disabled = false;
      }
    });
  }

  if (stopLocalImportBtn) {
    stopLocalImportBtn.addEventListener('click', () => {
      if (!window.confirm(localImportCancelConfirmMessage)) {
        return;
      }

      stopLocalImportSession();
    });
  }

  importBtn.addEventListener('click', async () => {
    if (!pickerSessionId) return;

    if (importBtn.disabled) {
      if (isLocalImport) {
        statusEl.textContent = 'ローカルインポートセッションでは手動インポートできません。';
      } else {
        statusEl.textContent = '{{ _("Import is not available for the current status.") }}';
      }
      return;
    }

    await withBusy(importBtn, async () => {
      try {
        const resp = await window.apiClient.post(`/api/picker/session/${encodeURIComponent(pickerSessionId)}/import`);

        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          console.error('Import start failed:', resp.status, text);
          statusEl.textContent = '{{ _("Failed to start import.") }}';
          showErrorToast('{{ _("Failed to start import.") }}');
          return;
        }

        statusEl.textContent = '{{ _("Import started.") }}';
        showSuccessToast('{{ _("Import started.") }}');
        refreshSelections();
      } catch (err) {
        console.error(err);
        statusEl.textContent = '{{ _("Failed to start import.") }}';
        showErrorToast('{{ _("Failed to start import.") }}');
      }
    });
  });

  const initialSessionFilters =
    filterStateApi && typeof filterStateApi.readSection === 'function'
      ? filterStateApi.readSection(SESSION_FILTER_SECTION)
      : null;

  applySessionFiltersFromState(initialSessionFilters);
  syncSessionFiltersToHash();

  if (filterStateApi && typeof filterStateApi.subscribeToSection === 'function') {
    filterStateApi.subscribeToSection(SESSION_FILTER_SECTION, (state) => {
      const nextState = state && typeof state === 'object' ? state : {};
      applySessionFiltersFromState(nextState);
      refreshSelections({ forceReset: true });
    });
  }

  setInterval(refreshSelections, 3000);
  refreshSelections();
});
</script>
{% endblock %}